# Game Programming Patterns
## Introduction
- 抽象和解耦让扩展代码更快更容易，但除非确信需要灵活性，否则不要在这上面浪费时间。
- 在整个开发周期中考虑并为性能设计，但是尽可能推迟那些底层的，基于假设的优化，那会锁死代码。
- 快速地探索游戏的设计空间，但不要跑的太快，在身后留下烂摊子。毕竟，你总得回来打扫。
- 如果打算抛弃这段代码，就不要尝试将其写完美。
- 最重要的是，如果你想要做出让人享受的东西，那就享受做它的过程。

## 命令模式
> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

> 命令是具现化的方法调用。

> 命令模式是一种回调的面向对象实现。


## 享元模式
> 不需要在一开始就创建所有享元，需要的时候再进行查找，如果没有创建则创建新的实例，如果已经创建则直接引用即可。

> 为了返回一个早先创建的享元，需要追踪那些已经实例化的对象池。正如其名，这意味着对象池是存储它们的好地方。

> 当使用状态模式时，经常会出现一些没有任何特定字段的“状态对象”，这个状态的标识和方法都很有用。你可以使用这个模式，然后在不同的状态机上使用相同的对象实例。

## 观察者模式
> 观察者模式是**同步的**。被观察者直接调用了观察者，这意味着直到所有观察者的通知方法返回后，被观察者才会继续自己的工作。观察者会阻塞被观察者的运行。如果要对事件同步响应，你需要完成响应，尽可能快的返回，这样UI或者其他逻辑就不会锁死。当你有耗时的操作要执行时，将这些操作推到另一个线程或工作队列中去。

> 你需要小心地在观察者中或者线程和锁。如果观察者试图获得被观察者拥有的锁，游戏就进入死锁了。在多线程引擎中，最好使用**事件队列**来做异步通信。

### 无须动态分配的方式——链式观察者
可以将观察者的列表分布到观察者自己中来解决动态分配问题。不是被观察者保留一列表分散的指针，观察者对象本身成为了链表的一部分：

![](http://gpp.tkchu.me/images/observer-linked.png)

由于我们使用观察者对象作为链表节点，这暗示它只能存在于一个观察者链表中。换言之，一个观察者一次只能观察一个被观察者。在传统的实现中，每个被观察者有独立的列表，一个观察者同时可以存在于多个列表中。

同时，我们可以使用“**链表节点池**”：由于这些节点都是同样大小和类型，可以预先在**对象池**中分配它们。这样你只需处理固定大小的列表节点，可以随你所需使用和重用，而无需牵扯到真正的内存分配器，从而避免动态分配。

### 注意的问题
1. 销毁被观察者和观察者问题
如果不小心的在某些观察者上面调用了的delete，被观察者也许仍然持有指向它的指针。那是一个指向一片已释放区域的悬挂指针，空指针异常便会抛出。

2. GC可能存在的问题
如果你的某一个UI监听逻辑处理的某一个事件，当UI退出时，忘记删除发布主题那里的引用，UI界面不在可见时，但也不会进入垃圾回收系统（因为还有残留的引用），每一次新的场景加载时，观察者列表不断地新增实例。这种情况被称为**失效监听者问题**，由于被观察者保留了对观察者的引用，最终有观察者实例僵死在内存中。这里的教训是要及时删除观察者。

## 原型模式
> 原型模式关键思路：**对象可以产出与它自己相近的对象。**

> OOP让你定义“对象”，将数据和代码绑定在一起。


## 单例模式
> 保证一个类只有一个实例，并且提供了访问该实例的全局访问点。

### 单例模式的优点
- **如果没人用，就不必创建实例（懒加载模式）**：节约内存和CPU循环总是好的。由于单例只在第一次被请求时实例化，如果游戏永远不请求，那么它不会被实例化

- **它在运行时实例化**：惰性初始化会使单例尽可能晚的初始化，所以当它初始化时，所有需要的信息都应该可用了。只要没有环状依赖，一个单例在初始化它自己时甚至可以引用另一个单例。

- **可继承单例**

    假设我们需要跨平台的文件系统封装类。为了达到这一点，我们需要它变成文件系统抽象出来的接口，而子类为每个平台实现接口。这是基类：

    ```[c++]
    class FileSystem() {}
    {
    public:
        virtual ~FileSystem() {}
        virtual char* readFile(char* path) = 0;
        virtual void writeFile(char* path, char* contents)
    };
    ```

    然后为一堆平台定义子类：

    ```[c++]
    class PS3FileSystem : public FileSystem
    {
    public:
        virtual char* readFile(char* path)
        {
            // 使用索尼的文件读写API......
        }

        virtual void writeFile(char* path, char* contents)
        {
            // 使用索尼的文件读写API......
        }
    };

    class WiiFileSystem : public FileSystem
    {
    public:
        virtual char* readFile(char* path)
        {
            // 使用任天堂的文件读写API......
        }

        virtual void writeFile(char* path, char* contents)
        {
            // 使用任天堂的文件读写API......
        }
    };
    ```

    下一步，将`FileSystem`变成单例：

    ```[c++]
    class FileSystem
    {
    public:
        static FileSystem& instance();

        virtual ~FileSystem() {}
        virtual char* readFile(char* path) = 0;
        virtual void writeFile(char* path, char* contents)

    protected:
        FileSystem() {}
    };
    ```

    灵巧之处在于如何创建实例：

    ```[c++]
    FileSystem& FileSystem::instance()
    {
    #if PLATFORM == PLAYSTATION3
        static FileSystem *instance = new PS3FileSystem();
    #elif PLATFORM == WII
        static FileSystem *instance = new WiiFileSystem();
    #endif

        return *instance;
    }
    ```

### 单例模式的危害
- **理解代码更加困难**

- **促进了耦合的发生**

- **对并行不友好**：当我们将某些东西转为全局变量时，我们创建了一块每个线程都能看到并访问的内存，却不知道其他线程是否正在使用那块内存。这种方式带来了死锁，竞争状态，以及其他很难解决的线程同步问题。

## 状态模式
### 有限状态机的要点
1. 你拥有状态机所有可能状态的集合
2. 状态机同时只能在一个状态
3. 一连串的输入或事件被发送给状态机
4. 每个状态都有一系列的转移，每个转移与输入和另一个状态相关

### 对状态模式的描述
> 允许一个对象在其内部状态发生变化时改变自己的行为，该对象看起来好像修改了它的类型。

### 优先状态机在以下情况有用
- 你有个实体，它的行为基于一些内在状态
- 状态可以被严格的分割为相对较少的不相干项目
- 实体响应一系列输入或事件

## 双缓冲模式
### 意图
> 用序列的操作模拟瞬间或者同时发生的事情

### 模式
> 定义**缓冲类**封装了**缓冲**：一段可改变的状态。这个缓冲被增量的修改，但我们想要外部的代码将修改视为单一的原子操作。为了实现这点，类保存两个缓冲实例：**下一缓冲**和**当前缓冲**。

> 当信息从缓冲区中读取，它总是读取当前的缓冲区。当信息需要写到缓存，它总是在下一缓冲区上操作。当改变完成后，一个**交换**操作会立刻将当前缓冲区和下一缓冲区交换，这样新缓冲区就是公共可见的了。旧的缓冲区成为下一个重用的缓冲区。

### 何时使用
- 我们需要维护一些被增量修改的状态
- 在修改到一半的时候，状态可能会被外部请求
- 我们想要防止请求状态的外部代码知道内部的工作方式
- 我们想要读取状态，而且不想等着修改完成

### 记住
1. 交换本身需要时间

    在状态被修改后，双缓冲需要一个**swap**步骤。这个操作必须是原子的——在交换时，没有代码可以接触到任何一个状态。通常，这就是修改一个指针那么快，但是如果交换消耗的时间长于修改状态的时间，那就毫无益处

2. 我们得保存两个缓冲区

    这个模式的另一个结果就是增加了内存的使用。

## 游戏循环
### 意图
> 将游戏的进行和玩家输入解耦，和处理器速度解耦

### 模式
一个**游戏循环**在游玩中不断运行。每一次循环，它无阻塞地**处理玩家输入**，**更新游戏状态**，**渲染游戏**。它追踪时间的消耗并控制游戏的速度。

### 设计决策
- **使用平台的事件循环**

    - **简单**：不必担心编写和优化自己的游戏核心循环
    - **平台友好**：不必明确地给平台一段时间让它处理它自己的时间，不必缓存事件，不必管理任何平台输入模型和你的不匹配之处
    - **失去了对时间的控制**：平台会在它方便时调用代码。

- **使用游戏引擎的循环**

    - **不必自己编写**：编写游戏循环非常需要技巧
    - **不必自己编写**：如果引擎无法满足你真正的需求，你也没法获得控制权

- **自己写**

    - **完全的控制**：可以做任何想做的事情，可以为游戏的需求定制开发
    - **需要与平台交互**：应用框架和操作系统通常需要时间片去处理自己的事件和其他工作。如果你拥有应用的核心循环，平台就没有这些时间片了。你得显式定期检查，保证框架没有挂起或者混乱

### 如何控制能量消耗
- **尽可能快的运行**

    这是PC游戏的常态。游戏循环永远不会显示告诉系统休眠。相反，空闲的循环被划在提升FPS或者图像显示效果上了。

- **固定帧率**

    移动游戏更加注重游戏的体验质量，而不是最大化图像画质。很多这种游戏都会设置最大帧率（通常是30或60FPS）。如果游戏循环在分配的时间片消耗完之前完成，剩余的时间它会休眠。

### 如何控制游戏速度
- **固定时间步长，没有同步**

    - 简单
    - 游戏速度直接受到硬件和游戏复杂度影响。主要的缺点是，如果有所变化，会直接影响游戏速度。游戏速度与游戏循环紧密相关

- **固定时间步长，有同步**

    - 还是很简单
    - 电量友好。这对移动游戏至关重要
    - 游戏不会运行的太快
    - 游戏可能运行的太慢。如果花了太多时间更新和渲染一帧，播放也会减缓。因为这种方案没有分离更新和渲染，它比更高级的方案更容易遇到这点。没法扔掉渲染帧来追上真实时间，游戏本身会变慢

- **动态时间步长**

    - 能适应并调整，避免运行得太快或者太慢。如果游戏不能追上真实时间，它用越来越长的时间步长更新，直到追上
    - 让游戏不确定而且不稳定

- **固定更新时间步长，动态渲染**

    - 能适应并调整，避免运行得太快或者太慢。只要能实时更新，游戏状态就不会落后于真实时间
    - 更复杂。主要负面问题是需要在实现中写更多东西。你需要将更新的时间步长调整的尽可能小来适应高端机，同时不至于在低端机上太慢

## 更新方法
### 意图
> 通过每次处理一帧的行为模拟一系列独立对象

### 模式
**游戏世界**管理**对象集合**。每个对象实现一个**更新方法**模拟对象在**一帧**内的行为。每一帧，游戏循环更新集合中的每一个对象。

### 何时使用
- 你的游戏有很多对象或系统需要同时运行
- 每个对象的行为都与其他的大部分独立
- 对象需要跟着时间进行模拟

### 设计决策
1. 更新方法在哪个类中？

    - **实体类中**

        如果你已经有实体类了，这是最简单的选项， 因为这不会带来额外的类。如果你需要的实体种类不多，这也许可行，但是业界已经逐渐远离这种做法了。

        当类的种类很多时，一有新行为就建Entity子类来实现是痛苦的。当你最终发现你想要用单一继承的方法重用代码时，你就卡住了。

    - **组件类**

        如果你已经使用了组件模式，你知道这个该怎么做。这让每个组件独立更新它自己。更新方法用了同样的方法解耦游戏中的实体，组件让你进一步解耦了单一实体中的各部分。渲染，物理，AI都可以自顾自了。

    - **委托类**

        还可将类的部分行为委托给其他的对象。状态模式可以这样做，你可以通过改变它委托的对象来改变它的行为。类型对象模式也这样做了，这样你可以在同“种”实体间分享行为。

2. 如何处理隐藏对象

    游戏中的对象，不管什么原因，可能暂时无需更新。它们可能是停用了，或者超出了屏幕，或者还没有解锁。如果状态中的这种对象很多，每帧遍历它们却什么都不做是在浪费CPU循环。

    1. 一种方法是管理单独的“活动”对象集合，那些存储真正需要更新的对象

        - **如果你使用单个包括了所有不活跃对象的集合**：**浪费时间**。对于不活跃对象，你要么检查一些“是否启用”的标识，要么调用一些啥都不做的方法。

        - **如果你使用单独的集合保存活动对象**：**使用了额外的内存管理第二个集合**。当你需要所有实体时，通常又需要一个巨大的集合。在那种情况下，这集合是多余的。在速度比内存要求更高的时候（通常如此），这取舍仍是值得的。

    2. 另一个权衡后的选择是使用两个集合，除了活动对象集合的另一个集合只包含不活跃实体而不是全部实体。

        - 得保持集合同步。当对象创建或完全销毁时（不是暂时停用），你得修改全部对象集合和活跃对象集合。

## 字节码
### 意图
> 将行为编码为虚拟机器上的指令，赋予其数据的灵活性

### 机器码的好处
- **密集的**。它是一块坚实连续的二进制数据块，没有一位被浪费
- **线性的**。指令被打成包，一条接一条的执行。不会在内存里到处乱跳
- **底层的**。每条指令都做一件小事，有趣的行为从组合中诞生
- **速度快**。在以上所有的要素作用下，机器码运行速度非常快

### 模式
**指令集**定义了可执行的底层操作。一系列的指令被编码为**字节序列**。**虚拟机**使用**中间值堆栈**依次执行这些指令。通过组合指令，可以定义复杂的高层行为。

### 何时使用
当需要定义很多行为，而游戏实现语言因为以下原因不能很好地完成任务时使用它：
- 过于底层，繁琐易错
- 编译时间长，迭代缓慢
- 安全性依赖编程者。如果想保证行为不会破坏游戏，你需要将其与代码的其他部分隔开

需要注意的是**字节码比本地代码慢**，所以不适合引擎的性能攸关部分。

### 设计决策
- **基于栈的虚拟机**

    - **指令短小**。由于每个指令隐式认定在栈顶寻找参数，不需要为任何数据编码。这意味着每条指令可能会非常短，一般只需一个字节。

    - **易于生成代码**。当你需要为生成字节码编写编译器或工具时，你会发现更容易生成基于栈的字节码。由于每个指令隐式在栈顶工作，你只需要以正确的顺序输出指令就可以在它们之间传递参数。

    - **会生成更多的指令**。每条指令只能看到栈顶。这意味着，产生像`a = b + c`这样的代码， 你需要单独的指令将`b`和`c`压入栈顶，执行操作，再将结果压入`a`。

- **基于寄存器的虚拟机**

    - **指令较长**。由于指令需要参数记录栈偏移量，单个指令需要更多的位。例如，一个`Lua`指令——可能是最著名的基于寄存器的虚拟机——占用完整的32位。它采用6位做指令类型，其余的是参数。

    - **指令较少**。由于每个指令可以做更多的工作，你不需要那么多的指令。有人说，性能会得以提升，因为不需要将值在栈中移来移去了。

### 可能需要的指令
- **外部基本操作原语**。这是虚拟机与引擎其他部分交互，影响玩家所见的部分。它们控制了字节码可以表达的真实行为。如果没有这些，你的虚拟机除了消耗CPU循环以外一无所得。

- **内部基本操作原语**。这些语句在虚拟机内操作数值——文字，算术，比较操作，以及操纵栈的指令。

- **控制流**。当你需要有条件执行或循环执行，你需要控制流。在字节码这样底层的语言，它们出奇的简单：跳转。

- **抽象**。如果用户开始在数据中定义很多的东西，最终要重用字节码的部分位，而不是复制和粘贴。你也许需要可调用过程这样的东西。

### 内部数值表示的不同形式
- **单一数据类型**

    - **简单易用** 你不必担心标记，转换，或类型检查。

    - **无法使用不同的数据类型** 这是明显的缺点。将不同类型成塞进单一的表示方式——比如将数字存储为字符串——这是找打。

- **带标记的类型**

    这是动态类型语言中常见的表示法。所有的值有两部分。第一部分是类型标识——一个enum——标识存储了数据的类型。

    - **数值知道其类型** 这个表示法的好处是可在运行时检查值的类型。这对动态调用很重要，可以确保没有在类型上面执行其不支持的操作。

    - **消耗更多内存** 每个值都要带一些额外的位来标识类型。在像虚拟机这样的底层，这里几位，那里几位，总量就会快速增加。

- **无标识的union**

    像前面一样使用union，但是没有类型标识。你可以将这些位表示为不同的类型，由你确保没有搞错值的类型。

    这是静态类型语言在内存中表示事物的方式。由于类型系统在编译时保证没弄错值的类型，不需要在运行时对其进行验证。

    - **结构紧凑** 找不到比只存储需要的值更加有效率的存储方式。

    - **速度快** 没有类型标识意味着在运行时无需消耗周期检查它们的类型。这是静态类型语言往往比动态类型语言快的原因之一。

    - **不安全** 这是真正的代价。一块错误的字节码，会让你误解一个值，把数字误解为指针，会破坏游戏安全导致崩溃。

- **接口**

    多种类型值的面向对象解决方案是通过多态。接口为不同的类型测试和转换提供虚方法。

    - **开放** 可在虚拟机的核心之外定义新的值类型，只要它们实现了基本接口就行。

    - **面向对象** 如果你坚持OOP原则，这是做事情“正确”的方式，为特定类型使用多态分配行为，而不是在标签上做switch之类的。

    - **冗长** 必须定义单独的类，包含了每个数据类型的相关行为。

    - **低效** 为了使用多态，必须使用指针，这意味着即使是短小的值，如布尔和数字，也得裹在堆中的对象里。每使用一个值，你就得做一次虚方法调用。

    在虚拟机核心之类的地方，像这样的性能影响会迅速叠加。事实上，这引起了许多我们试图在解释器模式中避免的问题。只是现在的问题不在代码中，而是在值中。

### 如何生成字节码
- **如果你定义基于文本的语言**

    - **必须定义语法**。业余和专业的语言设计师小看这件事情的难度。让解析器快乐很简单，让用户快乐很难。语法设计是用户界面设计，当你将用户界面限制到字符构成的字符串，这可没把事情变简单。

    - **必须实现解析器**。不管名声如何，这部分其实非常简单。无论使用ANTLR或Bison，还是——像我一样——手写递归下降，都可以完成。

    - **必须处理语法错误**。这是最重要和最困难的部分。当用户制造了语法和语义错误——他们总会这么干——引导他们返回到正确的道路是你的任务。解析器只知道接到了意外的符号，给予有用的的反馈并不容易。

    - **可能会对非技术用户关上大门**。我们程序员喜欢文本文件。结合强大的命令行工具，我们把它们当作计算机的乐高积木——简单，有百万种方式组合。大部分非程序员不这样想。对他们来说，输入文本文件就像为愤怒机器人审核员填写税表，如果忘记了一个分号就会遭到痛斥。

- **如果你定义了一个图形化创作工具**

    - **必须实现用户界面**。按钮，点击，拖动，诸如此类。有些人畏惧它，但我喜欢它。如果沿着这条路走下去，设计用户界面和工作核心部分同等重要——而不是硬着头皮完成的乱七八糟工作。每点额外工作都会让工具更容易更舒适地使用，并直接导致了游戏中更好的内容。如果你看看很多游戏制作过程的内部解密，经常会发现制作有趣的创造工具是秘诀之一。

    - **有较少的错误情况**。由于用户通过交互式一步一步地设计行为，应用程序可以尽快引导他们走出错误。而使用基于文本的语言时，直到用户输完整个文件才能看到用户的内容，更难预防和处理错误。

    - **更难移植**。文本编译器的好处是，文本文件是通用的。编译器简单地读入文件并写出。跨平台移植的工作实在微不足道。当你构建用户界面，你必须选择要使用的架构，其中很多是基于某个操作系统。也有跨平台的用户界面工具包，但他们往往要为对所有平台同样适用付出代价——对所有的平台上同样不适用。

## 子类沙箱
### 意图
> 用一系列由基类提供的操作定义子类中的行为。

### 模式
**基类**定义抽象的**沙箱方法**和几个**提供的操作**。将操作标为`protected`，表明它们只为子类所使用。每个推导出的**沙箱子类**用提供的操作实现了沙箱函数。

### 使用场景
- 你有一个能推导很多子类的基类。
- 基类可以提供子类需要的所有操作。
- 在子类中有行为重复，你想要更容易的在它们间分享代码。
- 你想要最小化子类和程序的其他部分的耦合。

### 设计决策
1. 首要原则

    - 如果提供的操作只被一个或几个子类使用，将操作加入基类获益不会太多。你向基类添加了会影响所有事物的复杂性，但是只有少数几个类获益。

    - 当你调用游戏中其他地方的方法，如果方法没有修改状态就有更少的干扰。它仍然制造耦合，但是这是“安全的”耦合，因为它没有破坏游戏中的任何东西。另一方面，修改状态的调用会和代码库的其他方面紧密绑定，需要三思。打包他们成基类提供的操作是个好的候选项。

    - 如果操作只是增加了向外部系统的转发调用，那它就没增加太多价值。那种情况下，也许直接调用外部系统的方法更简单。

2. 方法设计原则

    这个模式的挑战是基类中最终加入了很多方法。你可以将一些方法移到其他类中来缓和。基类通过返回对象提供方法。

    将提供的操作分流到辅助类可以为你做一些事情：

    - 减少基类中的方法。

    - 在辅助类中的代码通常更好管理。

    - 减少了基类和其他系统的耦合度。

### 基类如何获取需要的状态
- **将它传给基类构造器**。但是这样每个子类都需要构造器调用基类构造器并传递变量。这让子类接触了我们不想要它知道的状态。也造成了维护的负担。如果我们后续向基类添加状态，每个子类都需要修改并传递这个状态。

- **使用两阶初始化**。可将初始化分为两个部分：构造器不接受任何参数，只创建对象。然后，我们调用定义在基类的分离方法传入必要的参数数据。如：`xxx->init(particles);`。这种方法的问题是，你需要永远记得调用`init()`方法。

- **让状态静态化**。如果某一个需要的系统是**单例**，可以让状态是基类私有而静态的。游戏仍然要保持初始化状态，但是它只需要为整个游戏初始化一遍，而不是为每个实例初始化一遍。

- **使用服务定位器**。让基类拉取它需要的状态，做到这点的一种实现是使用**服务定位器**模式。

## 类型对象
### 意图
>创造一个类A来允许灵活的创造新“类型”，类A的每个实例都代表了不同的对象类型

### 模式
定义**类型对象**类和**有类型的对象**类。每个类型对象实例代表一种不同的逻辑类型。每种有类型的对象保存**对描述它类型的类型对象的引用**。

### 何时使用
在任何你需要定义不同“种”事物，但是语言自身的类型系统过于僵硬的时候使用该模式。尤其是下面两者之一成立时：

- 你不知道你后面还需要什么类型。（举个例子，如果你的游戏需要支持资料包，而资料包有新的怪物品种呢？）

- 修改或添加新类型不想改变代码或者重新编译就能。

### 类型对象封装还是暴露分析
- **如果类型对象是封装的**

    - **类型对象模式的复杂性对代码库的其他部分是隐藏的**。它成为了只有有类型的对象才需要考虑的实现细节。

    - **有类型的对象可以选择性地修改类型对象的重载行为**。

    - **我们得为每个类型对象暴露的方法写转发**。这是这个设计的冗长之处。如果类型对象有很多方法，对象类也得为每一个方法建立属于自己的公共可见方法。

- **如果类型对象是暴露的**

    - **外部代码可以与类型对象直接交互，无需拥有类型对象的实例**。如果类型对象是封装的，那么没有一个拥有它的对象就没法使用它。这阻止我们使用构造器模式这样的方法，在品种上调用方法来创建新怪物。如果用户不能直接获得品种，他们就没办法调用它。

    - **类型对象现在是对象公共API的一部分了**。大体上，窄接口比宽接口更容易掌控——你暴露给代码库其他部分的越少，你需要处理的复杂度和维护工作就越少。通过暴露类型对象，我们扩宽了对象的API，包含了所有类型对象提供的东西。

### 如何创建有类型的对象
- **构造对象然后传入类型对象**

    - **外部代码可以控制分配**。由于调用代码也是构建对象的代码，它可以控制其的内存位置。如果我们想要UI在多种内存场景中使用（不同的分配器，在栈中，等等），这给了完成它的灵活性。

- **在类型对象上调用“构造器”函数**

    - **类型对象控制了内存分配**。这是硬币的另一面。如果我们**不想**让用户选择在内存中何处创建对象， 在类型对象上调用工厂方法可以达到这一点。如果我们想保证所有的对象都来自具体的*对象池*或者其他的内存分配器时也有用。

### 能否改变类型
- **如果类型不改变**

    - **编码和理解都更容易**。在概念上，大多数人不期望“类型”会改变。这符合大多数人的理解。

    - **更容易查找漏洞**。如果我们试图追踪怪物进入奇怪状态时的漏洞，现在 看到的品种就是怪物始终保持的品种可以大大简化工作。

- **如果类型可以改变**

    - **需要创建的对象更少**。在我们的例子中，如果类型不能改变，我们需要消耗CPU循环创建新的僵尸怪物对象， 把原先对象中需要保留的属性都拷贝过来，然后删除它。如果我们可以改变类型，所有的工作都被一个简单的声明取代。

    - **我们需要小心地做约束**。在对象和它的类型间有强耦合是很自然的事情。举个例子，一个品种也许假设怪物**当前的**血量永远高于品种中的初始血量。

### 支持何种继承
- **没有继承**

    - **简单**。最简单的通常是最好的。如果你在类型对象间没有大量数据共享，为什么要为难自己呢？

    - **这会带来重复的工作**。我从未见过看到哪个编码系统中设计者不想要继承的。当你有十五种不同的精灵时，协调血量就要修改十五处同样的数字真是糟透了。

- **单继承**

    - **还是相对简单**。它易于实现，但是，更重要的是，也易于理解。如果非技术用户正在使用这个系统，要操作的部分越少越好。这就是很多编程语言只支持单继承的原因。这看起来是能力和简洁之间的平衡点。

    - **查询属性更慢**。为了在类型对象中获取一块数据，我们也许需要回溯继承链寻找是哪一个类型最终决定了值。在性能攸关的代码上，我们也许不想花时间在这上面。

- **多重继承**

   - **可以避免绝大多数代码重复**。使用优良的多继承系统，用户可以为类型对象建立几乎没有冗余的层次。改变数值时，我们可以避免很多复制和粘贴。

    - **复杂**。不幸的是，它的好处更多的是理论上的而非实际上的。多重继承很难理解。

## 组件模式
### 意图
> 允许单一的实体跨越多个领域而不会导致这些领域彼此耦合。

### 模式
**单一实体跨越了多个领域**。为了保证领域之间相互分离，将每部分代码放入**各自的组件类**中。实体被简化为组件的容器。

### 使用时机
组件通常在定义游戏实体的核心部分中使用，但它们在其它地方也有用。这个模式在如下情况中可以使用：

- 有一个设计了多个领域的类，而你想保持这些领域相互隔离。

- 一个类正在变大而且越来越难以使用。

- 想要能定义一系列分享不同能力的类，但是使用继承无法让你精确选取要重用的部分。

### 设计决策
1. 对象如何获取组件

    - **如果对象创建组件**

        - **这保证了对象总是能拿到需要的组件**。你永远不必担心某人忘记连接正确的组件，然后破坏了整个游戏。容器类自己会处理这个问题。

        - **重新设置对象比较困难**。这个模式的强力特性之一就是只需要重新组合组件就可以创建新的对象。如果对象总是用硬编码的组件组装自己，我们就无法利用这个特性。

    - **如果外部代码提供组件**

        - **对象更加灵活**。我们可以提供不同的组件，这样就能改变对象的行为。通过共用组件，对象变成了组件容器，我们可以为不同目的一遍又一遍重用它。

        - **对象可以与具体的组件类型解耦**。如果我们允许外部代码提供组件，好处是也可以传递派生的组件类型。这样，对象只知道组件接口而不知道组件的具体类型。这是一个很好的封装结构。

2. 组件之间如何通信

    - **通过修改容器对象的状态**

        - **这保持组件解耦**。互相通信的组件都不知道对方的存在。

        - **需要将组件分享的任何数据存储在容器类中**。通常状态只在几个组件间共享。

        - **使组建的通信基于组件运行的顺序**。如果有多个组件修改同一个值，或者读取该值的时机不正确或组件执行的顺序不同可能会导致游戏结果发生不同。


    - **通过它们之间相互引用**

        - **简单快捷**。通信是一个对象到另一个的直接方法调用。组件可以调用任一引用对象的方法。

        - **两个组件紧邦在一起**。

    - **通过发送消息**

        - 这是最复杂的选项，我们可以在容器类中建立消息系统，允许组件相互发送消息。

        - **同级组件解耦**。通过父级容器对象，就像共享状态的方案一样，我们保证了组件之间仍然是解耦的。使用了这套系统，组件之间唯一的耦合是它们发送的消息。

        - **容器类很简单**。不像使用共享状态那样，容器类无需知道组件使用了什么数据，它只是将消息发送出去。这可以让组件发送领域特有的数据而无需打扰容器对象。

## 事件队列
### 意图
> 解耦发出消息或事件的时间和处理它的时间。

### 模式
**事件队列**在队列中按先入先出的顺序存储一系列**通知或请求**。发送通知时，**将请求放入队列并返回**。处理请求的系统之后稍晚**从队列中获取请求**并处理。这**解耦了发送者和接受者**，既**静态**又**及时**。

### 设计决策
1. 队列中存储什么

    - **如果你存储事件**

        “事件”或者“通知”描绘已经发生的事情，比如“怪物死了”。你入队它，这样其他对象可以对这个事件作出回应，有点像异步的**观察者模式**。

        - **很可能允许多个监听者**。由于队列包含的是已经发生的事情，发送者可能不关心谁接受它。从这个层面来说，事件发生在过去，早已被遗忘。

        - **访问队列的模块更广**。事件队列通常广播事件到任何感兴趣的部分。为了最大程度允许哪些部分能感兴趣，队列一般是全局可见的。

    - **如果你存储消息**

        “消息”或“请求”描绘了想要发生在未来的事情，比如“播放声音”。可以将其视为服务的异步API。

        - **更可能只有一个监听者**。比如存储的消息只请求音频API播放声音。

2. 谁能从队列中读取


    - **单播队列**

        - **队列变成了读取者的实现细节**。发送者知道的所有事就是发条消息。

        - **队列更封装**。其他都一样时，越多封装越方便。

        - **无须担心监听者之间的竞争**。使用多个监听者，你需要决定每个队列中的事物一对多分给全部的监听者（广播）还是每个队列中的事物一对一分给单独的监听者（更加像工作队列）。

    - **广播队列**

        这是大多数“事件”系统工作的方法。如果有十个监听者，一个事件进来，所有监听者都能看到这个事件。

        - **事件可能无人接受**。前面那点的必然推论就是如果有零个监听者，没有谁能看到这个事件。在大多数广播系统中，如果处理事件时没有监听者，事件就消失了。

        - **也许需要过滤事件**。广播队列经常对程序的所有部分可见，最终你会获得一系列监听者。很多事件乘以很多监听者，你会获取一大堆事件处理器。

    - **工作队列**

        类似广播队列，有多个监听器。不同之处在于每个队列中的东西只会投到监听器其中的一个。常应用于将工作打包给同时运行的线程池。

        - **你得规划**。由于一个事物只有一个监听器，队列逻辑需要指出最好的选项。这也许像round robin算法或者乱序选择一样简单，或者可以使用更加复杂的优先度系统。

3. 谁能写入队列

    - **使用单个写入器**

        这种风格和同步的**观察者模式**很像。有特定对象收集所有可接受的事件。

        - **你隐式知道事件是从哪里来的**。由于这里只有一个对象可向队列添加事件，任何监听器都可以安全的假设那就是发送者。

        - **通常允许多个读取者**。你可以使用单发送者对单接收者的队列，但是这样沟通系统更像纯粹的队列数据结构。

    - **使用多个写入器**

        代码库的任何部分都能给队列添加请求。“全局”或“中心”事件总线像这样工作。

        - **得更小心环路**。由于任何东西都有可能向队列中添加东西，这更容易意外地在处理事件时添加事件。如果你不小心，那可能会触发反馈循环。

        - **很可能需要在事件中添加对发送者的引用**。当监听者接到事件时，它不知道是谁发送的，因为可能是任何人。如果它确实需要知道发送者，你得将发送者打包到事件对象中去，这样监听者才可以使用它。

4. 对象在队列中的生命周期

    使用同步的通知，当所有的接收者完成了消息处理才会返回发送者。这意味着消息本身可以安全的存在栈的局部变量中。使用队列，消息比让它入队的调用活得更久。

    如果你是用有垃圾回收的语言，你无需过度担心这个。消息存到队列中，会一直存到需要它的时候。而在C或C++中，得由你来保证对象活的足够长。

    - **传递所有权**

        这是手动管理内存的传统方法。当消息入队时，队列拥有了它，发送者不再拥有它。当它被处理时，接收者获取了所有权，负责销毁他。

    - **共享所有权**

        现在，甚至C++程序员都更适应垃圾回收了，分享所有权更加可接受。这样，消息只要有东西对其有引用就会存在，当被遗忘时自动释放。

    - **队列拥有它**

        另一个选项是让消息永远存在于队列中。发送者不再自己分配消息的内存，它向内存请求一个“新的”消息。队列返回一个队列中已经在内存的消息的引用，接收者引用队列中相同的消息。

## 服务定位器
### 意图
> 提供服务的全局接入点，避免使用者和实现服务的具体类耦合。

### 模式
**服务**类定义了一堆操作的抽象接口。具体的**服务提供者**实现这个接口。分离的**服务定位器**提供了通过查询获取服务的方法，同时隐藏了服务提供者的具体细节和定位它的过程。

### 记住
1. **服务必须真的可定位**

2. **服务不知道谁在定位它**

### 设计决策
1. **服务是如何被定位的**
    - **外部代码注册**

        - **简单快捷**。

        - **可以控制如何构建提供者**。

        - **可以在游戏运行时改变服务**。

        - **定位器以来外部代码**。这是缺点。任何访问服务的代码必须假定在某处的代码已经注册过服务了。如果没有做初始化，要么游戏会崩溃，要么服务会神秘的不工作。

    - **在编译时绑定**

        - **快速**。所有的工作都在编译时完成，在运行时无需完成任何东西。

        - **能保证服务是可用的**。由于定位器现在拥有服务，在编译时就进行了定位，我们可以保证游戏如果能完成编译，就不必担心服务不可用。

        - **无法轻易改变服务**。这是主要的缺点。由于绑定发生在编译时，任何时候你想要改变服务，都得重新编译并重启游戏。

    - **在运行时设置**

        可以根据加载的设置文件来确认提供者，然后使用反射在运行时实例化这个类。

        - **我们可以更换服务而无需重新编译**。这比编译时绑定多了小小的灵活性，但是不像注册那样灵活，那里你可以真正的在运行游戏的时候改变服务。

        - **非程序员也可改变服务**。这对于设计者师很好的，他们想要开关某项游戏特性，但修改源代码并不舒服。

        - **同样的代码库可以同时支持多种设置**。由于从代码库中完全移出了定位处理，我们可以使用相同的代码来同时支持多种服务设置。

        - **复杂**。不像前面的解决方案，这个方案是重量级的。你得创建设置系统，也许要写代码来加载和粘贴文件，通常要做些事情来定位服务。

        - **加载服务需要时间**。现在你眉会头紧蹙了。在运行时设置意味着你在消耗CPU循环加载服务。

2. **如果服务不能被定位怎么办**

    - **让使用者处理它**

        最简单的解决方案就是把责任推回去。如果定位器不能找到服务，只需返回NULL。

        - **让使用者决定如何掌控失败**。使用者也许在收到找不到服务的关键错误时应该暂停游戏。其他时候可能可以安全地忽视并继续。如果定位器不能定义全面的政策应对所有的情况，那么就将失败传回去，让每个使用者决定什么是正确的回应。

        - **使用服务的用户必须处理失败**。当然，这个的必然结果是每个使用者都必须检查服务的失败。如果它们都以相同方式来处理，在代码库中就有很多重复的代码。如果一百个中有一个忘了检查，游戏就会崩溃。

    - **挂起游戏**

        可以使用断言，当提供者为空时，终止整个程序。

        - **使用者不必处理缺失的服务**。也许简单的服务在成百上千的地方使用，这节约了很多代码。通过声明定位器永远能够提供服务，我们节约了使用者处理它的精力。

        - **如果服务没有找到，游戏会挂起**。在极少的情况下，服务真的找不到，游戏就会挂起。强迫我们解决定位服务的漏洞是好事（比如一些本该调用的初始化代码没有被调用）， 但被阻塞的所有人都得等到漏洞修复时。与大型开发团队工作时，当这种事情发生时，会增加痛苦的停工时间。

    - **返回空服务**

        - **使用者不必处理缺失的服务**。就像前面的选项一样，我们保证了总是会返回可用的服务，简化了使用服务的代码。

        - **如果服务不可用，游戏仍将继续**。这有利有弊。让我们在没有服务的情况下依然能运行游戏是很有用的。在大团队中，当我们工作依赖的其他特性或者依赖的其他系统还没有就位时，这也是很有用的。**缺点在于，较难查找无意缺失服务的漏洞**。

3. **服务的服务范围有多大**

    - **全局可访问**

        - **鼓励整个代码库使用同样的服务**。大多数服务都被设计成单一的。通过允许整个代码库接触到相同的服务，我们可以避免代码因不能获取“真正的”服务而到处实例化提供者。

        - **我们失去了何时何地使用服务的控制权**。这是让某物全局化的明显代价——任何东西都能接触它。

    - **限制在某个类中**

        - **我们控制了耦合**。这是主要的优点。通过显式限制服务到继承树的一个分支上，应该解耦的系统保持了解耦。

        - **可能导致重复的付出**。潜在的缺点是如果一对无关的类确实需要接触服务，每个类都要拥有服务的引用。无论是谁定位或者注册服务，它也需要在这些类之间重复处理。

## 数据局部性
### 意图
> 合理组织数据，充分使用CPU的缓存来加速内存读取。

### 模式
现代的CPU有**缓存来加速内存读取**。它可以**更快的读取最近访问过的内存的毗邻内存**。通过**提高内存局部性**来提高性能——保证数据**以处理顺序排列在连续内存上**。

### 何时使用
就像大多数优化方案，使用数据局部性的第一准则是**在遇到性能问题时使用**。不要将其应用在代码库不经常使用的角落上。优化代码不会让你过得更轻松，因为其结果往往更加复杂，更加缺乏灵活性。

就本模式而言，还得确认你的性能问题**确实由缓存不命中引发**。如果代码是因为其他原因而缓慢，这个模帮不上忙。

### 设计决策
1. **你如何处理多台**

    - **别这么干**

        最简单的解决方案是避免子类，至少在做内存优化的部分避免使用。

        - **简洁安全**。你知道在处理什么类，所有的对象都是同样大小。

        - **更快**。动态调用意味着在跳转表中寻找方法，然后跟着指针寻找特定的代码。这种消耗在不同硬件区别很大，但动态调用总会带来一些代价。

        - **不灵活**。当然，使用动态调用的原因就是它给了在不同对象间展示不同的行为的强大能力。

    - **为每种类型使用分离的数组**

        - **对象被紧密的排列着**。每个数组只包含同类的对象，这里没有填充或者其他的古怪。

        - **静态调度**。一旦获得了对象的类型，你不必在所有时候使用多态。你可以使用常规的非虚方法调用。

        - **得追踪每个集合**。如果你有很多不同类型，这种管理每种类型分别的数组可是件苦差事。

        - **得明了每一种类型**。由于你为每种类型管理分离的集合，你无法解耦类型集合。多态的魔力之一在于它是开放的——与一个接口交互的代码可以与实现此接口的众多类型解耦。

    - **使用指针的集合**

        - **灵活**。这样构建集合的代码可以与任何支持接口的类工作。完全开放。

        - **对缓存不友好**。当然，我们在这里讨论其他方案的原因就是指针跳转导致的缓存不友好。但是，记住，如果代码不是性能攸关的，这很有可能是行得通的。

2. **游戏实体如何定义**

    - **如果游戏实体是拥有它组件指针的类**

        - **你可以将实体存储到连续数组中**。既然游戏实体不在乎组件在哪里，你可以将组件好好打包，组织数组中，来优化遍历。

        - **拿到一个实体，可以轻易的获得它的组件**。就在一次指针跳转后的位置。

        - **在内存中移动组件很难**。当组件启用或者关闭时，你可能想要在数组中移动它们，保证启用的组件位于前列。如果在实体中有指针指向组件时直接移动该组件，一不小心指针就会损毁。你得保证同时更新指向组件的指针。

    - **如果游戏实体是拥有组件ID的类**

        使用裸指针的挑战在于内存中移动它很难。你可以使用更加直接的方案：使用ID或者索引来**查找**组件。

        - **更复杂**。ID系统不是高科技，但是还是需要比指针多做些事情。你得实现它然后排除漏洞，这里需要消耗内存。

        - **更慢**。很难比直接使用指针更快。需要使用搜索或者哈希来帮助实体找到它的组件。

        - **你需要访问组件“管理器”**。基本思路是用抽象的ID标识组件。你可以使用它来获得对应组件对象的引用。但是为了做到这点，你需要让ID有办法找到对应的组件。正是包裹着整个连续组件数组的对所要做的。通过裸指针，如果你有游戏实体，你可以直接找到组件，而这种方式你需要接触游戏实体和**组件注册器**。

    - **如果游戏实体本身就是一个ID**

        - **实体很小**。当你想要传递游戏实体的引用时，只需一个简单的值。

        - **实体是空的**。当然，将所有东西移出实体的代价是，你必须将所有东西移出。不能再拥有组件独有的状态和行为，这样更加依赖于组件模式。

        - **不必管理实体的生命周期**。由于实体只是内置值类型，不需要被显式分配和释放。当它所有的组件都被释放时，对象就隐式“死亡”了。

        - **查找实体的某一组件也许会很慢**。这和前一方案有相同的问题，但在另一个方向上。为了找某个实体的组件，你需要给ID做对象映射。这一过程消耗也许很大。

## 脏标识模式
### 意图
> 将工作延期至需要其结果时才去执行，避免不必要的工作。

### 模式
一组**原始数据**随着时间变化而改变。使用**昂贵的过程**推定一组**导出数据**。一个**“脏标识**追踪导出数据是否与原始数据保持一致。它在**原始数据改变时被设置**。如果导出数据被请求时，该标识被设置了，那么**重新计算并清除标识**，否则的话，使用之前**缓存的导出数据**。

### 何时使用
- **原始数据的变化速度远高于导出数据的使用速度**。避免在导出数据使用前原始数据多次变化带来的不必要计算。

- **增量更新十分困难**。

### 记住
- **延期太久是有代价的**

    这个模式将某些耗时的工作延期到真正需要结果的时候，但是当它要的时候，通常是**现在就要**。但是我们使用这个模式的原因是计算很耗时。

    延期的另一个问题是，如果有东西出错了，可能根本无法弥补。当使用这个模式将状态持久化时，问题更加突出。

- **每次状态改变都得保证设置标识**

    由于推导数据是从原始数据推导而来的，它本质上是缓存。无论何时缓存了数据，都是需要保证**缓存一致性**——在缓存与原始数据不同步时通知之。在这个模式上，这意味着在**任何**原始数据变化时设置脏标识。

- **得将之前的推导数据保存在内存之中**

    当推导数据被请求而脏标识没有设置，就使用之前计算出的数据。这很明显，但这需要在内存中保存推导数据，以防之后再次使用。

### 设计决策
1. **什么时候清空脏标识**

    - **当结果被请求时**

        - **如果不需要结果，可以完全避免计算**。如果原始数据变化的速度比推导数据获取的速度快得多，这效果很明显。

        - **如果计算消耗大量时间，这会造成可察觉的卡顿**。将工作推迟到玩家想要结果的时候会严重影响游戏体验。

    - **在精心设计的检查点处**

        - **这种工作不会影响到玩家体验**。不像前一个选项，游戏在紧张运行时，你总能转移玩家的注意力。

        - **在工作时丧失了控制权**。这和前一个选项相反。你在处理时能进行微观控制，确保有效优雅地处理它。你不能保证玩家真的到了检查点或者满足了定义的条件。如果他们在游戏中迷失了，或者游戏进入了奇怪的状态，最终工作会推迟得超乎预料的晚。

    - **在后台处理**

        通常情况下，你为第一次更改时启动固定时长的计时器，然后在计时器到时间后处理之间的所有变化。

        - **可以控制工作进行的频率**。通过调节计时器，可以保证它发生的像预期一样频繁（或者不频繁）。

        - **更多的冗余工作**。如果原始状态在计时器运行之间只改变了很少的部分，最终大部分处理的都是没有改变的数据。

        - **需要支持异步工作**。在“后台”处理数据意味着玩家可以同时继续做事。这就意味着你将会需要线程或者其他并行支持，这样游戏在处理数据的同时仍然可以继续游玩。

2. **脏追踪的粒度有多细？**

    - **如果粒度更细**
        
        - 你只需处理真正改变的数据。

    - **如果粒度更粗**
        
        - 最终需要处理没有变化的数据。
        
        - 用在存储脏标识上的内存更少。

        - 固定开销花费的时间更少。当处理某些修改后的数据时，通常处理数据之前有些固定的工作要做。