# Game Programming Patterns
## Introduction
- 抽象和解耦让扩展代码更快更容易，但除非确信需要灵活性，否则不要在这上面浪费时间。
- 在整个开发周期中考虑并为性能设计，但是尽可能推迟那些底层的，基于假设的优化，那会锁死代码。
- 快速地探索游戏的设计空间，但不要跑的太快，在身后留下烂摊子。毕竟，你总得回来打扫。
- 如果打算抛弃这段代码，就不要尝试将其写完美。
- 最重要的是，如果你想要做出让人享受的东西，那就享受做它的过程。

## 重访设计模式
### 命令模式
> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

> 命令是具现化的方法调用。

> 命令模式是一种回调的面向对象实现。


### 享元模式
> 不需要在一开始就创建所有享元，需要的时候再进行查找，如果没有创建则创建新的实例，如果已经创建则直接引用即可。

> 为了返回一个早先创建的享元，需要追踪那些已经实例化的对象池。正如其名，这意味着对象池是存储它们的好地方。

> 当使用状态模式时，经常会出现一些没有任何特定字段的“状态对象”，这个状态的标识和方法都很有用。你可以使用这个模式，然后在不同的状态机上使用相同的对象实例。

### 观察者模式
> 观察者模式是**同步的**。被观察者直接调用了观察者，这意味着直到所有观察者的通知方法返回后，被观察者才会继续自己的工作。观察者会阻塞被观察者的运行。如果要对事件同步响应，你需要完成响应，尽可能快的返回，这样UI或者其他逻辑就不会锁死。当你有耗时的操作要执行时，将这些操作推到另一个线程或工作队列中去。

> 你需要小心地在观察者中或者线程和锁。如果观察者试图获得被观察者拥有的锁，游戏就进入死锁了。在多线程引擎中，最好使用**事件队列**来做异步通信。

#### 无须动态分配的方式——链式观察者
可以将观察者的列表分布到观察者自己中来解决动态分配问题。不是被观察者保留一列表分散的指针，观察者对象本身成为了链表的一部分：

![](http://gpp.tkchu.me/images/observer-linked.png)


由于我们使用观察者对象作为链表节点，这暗示它只能存在于一个观察者链表中。换言之，一个观察者一次只能观察一个被观察者。在传统的实现中，每个被观察者有独立的列表，一个观察者同时可以存在于多个列表中。

同时，我们可以使用“**链表节点池**”：由于这些节点都是同样大小和类型，可以预先在**对象池**中分配它们。这样你只需处理固定大小的列表节点，可以随你所需使用和重用，而无需牵扯到真正的内存分配器，从而避免动态分配。

#### 注意的问题
1. 销毁被观察者和观察者问题
如果不小心的在某些观察者上面调用了的delete，被观察者也许仍然持有指向它的指针。那是一个指向一片已释放区域的悬挂指针，空指针异常便会抛出。

2. GC可能存在的问题
如果你的某一个UI监听逻辑处理的某一个事件，当UI退出时，忘记删除发布主题那里的引用，UI界面不在可见时，但也不会进入垃圾回收系统（因为还有残留的引用），每一次新的场景加载时，观察者列表不断地新增实例。这种情况被称为**失效监听者问题**，由于被观察者保留了对观察者的引用，最终有观察者实例僵死在内存中。这里的教训是要及时删除观察者。

### 原型模式
> 原型模式关键思路：**对象可以产出与它自己相近的对象。**

> OOP让你定义“对象”，将数据和代码绑定在一起。


### 单例模式
> 保证一个类只有一个实例，并且提供了访问该实例的全局访问点。

#### 单例模式的优点
- **如果没人用，就不必创建实例（懒加载模式）**：节约内存和CPU循环总是好的。由于单例只在第一次被请求时实例化，如果游戏永远不请求，那么它不会被实例化

- **它在运行时实例化**：惰性初始化会使单例尽可能晚的初始化，所以当它初始化时，所有需要的信息都应该可用了。只要没有环状依赖，一个单例在初始化它自己时甚至可以引用另一个单例。

- **可继承单例**

    假设我们需要跨平台的文件系统封装类。为了达到这一点，我们需要它变成文件系统抽象出来的接口，而子类为每个平台实现接口。这是基类：

    ```[c++]
    class FileSystem() {}
    {
    public:
        virtual ~FileSystem() {}
        virtual char* readFile(char* path) = 0;
        virtual void writeFile(char* path, char* contents)
    };
    ```
    
    然后为一堆平台定义子类：
    
    ```[c++]
    class PS3FileSystem : public FileSystem
    {
    public:
        virtual char* readFile(char* path)
        {
            // 使用索尼的文件读写API......
        }
        
        virtual void writeFile(char* path, char* contents)
        {
            // 使用索尼的文件读写API......
        }
    };
    
    class WiiFileSystem : public FileSystem
    {
    public:
        virtual char* readFile(char* path)
        {
            // 使用任天堂的文件读写API......
        }
        
        virtual void writeFile(char* path, char* contents)
        {
            // 使用任天堂的文件读写API......
        }
    };
    ```
    
    下一步，将`FileSystem`变成单例：
    
    ```[c++]
    class FileSystem
    {
    public:
        static FileSystem& instance();
        
        virtual ~FileSystem() {}
        virtual char* readFile(char* path) = 0;
        virtual void writeFile(char* path, char* contents)
        
    protected:
        FileSystem() {}
    };
    ```
    
    灵巧之处在于如何创建实例：
    
    ```[c++]
    FileSystem& FileSystem::instance()
    {
    #if PLATFORM == PLAYSTATION3
        static FileSystem *instance = new PS3FileSystem();
    #elif PLATFORM == WII
        static FileSystem *instance = new WiiFileSystem();
    #endif
    
        return *instance;
    }
    ```

#### 单例模式的危害
- **理解代码更加困难**

- **促进了耦合的发生**

- **对并行不友好**：当我们将某些东西转为全局变量时，我们创建了一块每个线程都能看到并访问的内存，却不知道其他线程是否正在使用那块内存。这种方式带来了死锁，竞争状态，以及其他很难解决的线程同步问题。

### 状态模式
#### 有限状态机的要点
1. 你拥有状态机所有可能状态的集合
2. 状态机同时只能在一个状态
3. 一连串的输入或事件被发送给状态机
4. 每个状态都有一系列的转移，每个转移与输入和另一个状态相关

#### 对状态模式的描述
> 允许一个对象在其内部状态发生变化时改变自己的行为，该对象看起来好像修改了它的类型。

#### 优先状态机在以下情况有用
- 你有个实体，它的行为基于一些内在状态
- 状态可以被严格的分割为相对较少的不相干项目
- 实体响应一系列输入或事件

### 双缓冲模式
#### 意图
> 用序列的操作模拟瞬间或者同时发生的事情

#### 模式
> 定义**缓冲类**封装了**缓冲**：一段可改变的状态。这个缓冲被增量的修改，但我们想要外部的代码将修改视为单一的原子操作。为了实现这点，类保存两个缓冲实例：**下一缓冲**和**当前缓冲**。

> 当信息从缓冲区中读取，它总是读取当前的缓冲区。当信息需要写到缓存，它总是在下一缓冲区上操作。当改变完成后，一个**交换**操作会立刻将当前缓冲区和下一缓冲区交换，这样新缓冲区就是公共可见的了。旧的缓冲区成为下一个重用的缓冲区。

#### 何时使用
- 我们需要维护一些被增量修改的状态
- 在修改到一半的时候，状态可能会被外部请求
- 我们想要防止请求状态的外部代码知道内部的工作方式
- 我们想要读取状态，而且不想等着修改完成

#### 记住
1. 交换本身需要时间

    在状态被修改后，双缓冲需要一个**swap**步骤。这个操作必须是原子的——在交换时，没有代码可以接触到任何一个状态。通常，这就是修改一个指针那么快，但是如果交换消耗的时间长于修改状态的时间，那就毫无益处
    
2. 我们得保存两个缓冲区

    这个模式的另一个结果就是增加了内存的使用。

### 游戏循环
#### 意图
将游戏的进行和玩家输入解耦，和处理器速度解耦

