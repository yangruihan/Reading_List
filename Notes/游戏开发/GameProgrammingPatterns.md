# Game Programming Patterns
## Introduction
- 抽象和解耦让扩展代码更快更容易，但除非确信需要灵活性，否则不要在这上面浪费时间。
- 在整个开发周期中考虑并为性能设计，但是尽可能推迟那些底层的，基于假设的优化，那会锁死代码。
- 快速地探索游戏的设计空间，但不要跑的太快，在身后留下烂摊子。毕竟，你总得回来打扫。
- 如果打算抛弃这段代码，就不要尝试将其写完美。
- 最重要的是，如果你想要做出让人享受的东西，那就享受做它的过程。

## 重访设计模式
### 命令模式
> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

> 命令是具现化的方法调用。

> 命令模式是一种回调的面向对象实现。


### 享元模式
> 不需要在一开始就创建所有享元，需要的时候再进行查找，如果没有创建则创建新的实例，如果已经创建则直接引用即可。

> 为了返回一个早先创建的享元，需要追踪那些已经实例化的对象池。正如其名，这意味着对象池是存储它们的好地方。

> 当使用状态模式时，经常会出现一些没有任何特定字段的“状态对象”，这个状态的标识和方法都很有用。你可以使用这个模式，然后在不同的状态机上使用相同的对象实例。

### 观察者模式
> 观察者模式是**同步的**。被观察者直接调用了观察者，这意味着直到所有观察者的通知方法返回后，被观察者才会继续自己的工作。观察者会阻塞被观察者的运行。如果要对事件同步响应，你需要完成响应，尽可能快的返回，这样UI或者其他逻辑就不会锁死。当你有耗时的操作要执行时，将这些操作推到另一个线程或工作队列中去。

> 你需要小心地在观察者中或者线程和锁。如果观察者试图获得被观察者拥有的锁，游戏就进入死锁了。在多线程引擎中，最好使用**事件队列**来做异步通信。

#### 无须动态分配的方式——链式观察者
可以将观察者的列表分布到观察者自己中来解决动态分配问题。不是被观察者保留一列表分散的指针，观察者对象本身成为了链表的一部分：

![](http://gpp.tkchu.me/images/observer-linked.png)


由于我们使用观察者对象作为链表节点，这暗示它只能存在于一个观察者链表中。换言之，一个观察者一次只能观察一个被观察者。在传统的实现中，每个被观察者有独立的列表，一个观察者同时可以存在于多个列表中。

同时，我们可以使用“**链表节点池**”：由于这些节点都是同样大小和类型，可以预先在**对象池**中分配它们。这样你只需处理固定大小的列表节点，可以随你所需使用和重用，而无需牵扯到真正的内存分配器，从而避免动态分配。

#### 注意的问题
1. 销毁被观察者和观察者问题
如果不小心的在某些观察者上面调用了的delete，被观察者也许仍然持有指向它的指针。那是一个指向一片已释放区域的悬挂指针，空指针异常便会抛出。

2. GC可能存在的问题
如果你的某一个UI监听逻辑处理的某一个事件，当UI退出时，忘记删除发布主题那里的引用，UI界面不在可见时，但也不会进入垃圾回收系统（因为还有残留的引用），每一次新的场景加载时，观察者列表不断地新增实例。这种情况被称为**失效监听者问题**，由于被观察者保留了对观察者的引用，最终有观察者实例僵死在内存中。这里的教训是要及时删除观察者。

### 原型模式
> 原型模式关键思路：**对象可以产出与它自己相近的对象。**

> OOP让你定义“对象”，将数据和代码绑定在一起。


