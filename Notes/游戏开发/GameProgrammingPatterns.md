# Game Programming Patterns
## Introduction
- 抽象和解耦让扩展代码更快更容易，但除非确信需要灵活性，否则不要在这上面浪费时间。
- 在整个开发周期中考虑并为性能设计，但是尽可能推迟那些底层的，基于假设的优化，那会锁死代码。
- 快速地探索游戏的设计空间，但不要跑的太快，在身后留下烂摊子。毕竟，你总得回来打扫。
- 如果打算抛弃这段代码，就不要尝试将其写完美。
- 最重要的是，如果你想要做出让人享受的东西，那就享受做它的过程。

## 重访设计模式
### 命令模式
> 将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

> 命令是具现化的方法调用。

> 命令模式是一种回调的面向对象实现。


### 享元模式
> 不需要在一开始就创建所有享元，需要的时候再进行查找，如果没有创建则创建新的实例，如果已经创建则直接引用即可。

> 为了返回一个早先创建的享元，需要追踪那些已经实例化的对象池。正如其名，这意味着对象池是存储它们的好地方。

> 当使用状态模式时，经常会出现一些没有任何特定字段的“状态对象”，这个状态的标识和方法都很有用。你可以使用这个模式，然后在不同的状态机上使用相同的对象实例。

### 观察者模式
> 观察者模式是**同步的**。被观察者直接调用了观察者，这意味着直到所有观察者的通知方法返回后，被观察者才会继续自己的工作。观察者会阻塞被观察者的运行。如果要对事件同步响应，你需要完成响应，尽可能快的返回，这样UI或者其他逻辑就不会锁死。当你有耗时的操作要执行时，将这些操作推到另一个线程或工作队列中去。

> 你需要小心地在观察者中或者线程和锁。如果观察者试图获得被观察者拥有的锁，游戏就进入死锁了。在多线程引擎中，最好使用**事件队列**来做异步通信。

#### 无须动态分配的方式——链式观察者
可以将观察者的列表分布到观察者自己中来解决动态分配问题。不是被观察者保留一列表分散的指针，观察者对象本身成为了链表的一部分：

![](http://gpp.tkchu.me/images/observer-linked.png)


由于我们使用观察者对象作为链表节点，这暗示它只能存在于一个观察者链表中。换言之，一个观察者一次只能观察一个被观察者。在传统的实现中，每个被观察者有独立的列表，一个观察者同时可以存在于多个列表中。

同时，我们可以使用“**链表节点池**”：由于这些节点都是同样大小和类型，可以预先在**对象池**中分配它们。这样你只需处理固定大小的列表节点，可以随你所需使用和重用，而无需牵扯到真正的内存分配器，从而避免动态分配。

#### 注意的问题
1. 销毁被观察者和观察者问题
如果不小心的在某些观察者上面调用了的delete，被观察者也许仍然持有指向它的指针。那是一个指向一片已释放区域的悬挂指针，空指针异常便会抛出。

2. GC可能存在的问题
如果你的某一个UI监听逻辑处理的某一个事件，当UI退出时，忘记删除发布主题那里的引用，UI界面不在可见时，但也不会进入垃圾回收系统（因为还有残留的引用），每一次新的场景加载时，观察者列表不断地新增实例。这种情况被称为**失效监听者问题**，由于被观察者保留了对观察者的引用，最终有观察者实例僵死在内存中。这里的教训是要及时删除观察者。

### 原型模式
> 原型模式关键思路：**对象可以产出与它自己相近的对象。**

> OOP让你定义“对象”，将数据和代码绑定在一起。


### 单例模式
> 保证一个类只有一个实例，并且提供了访问该实例的全局访问点。

#### 单例模式的优点
- **如果没人用，就不必创建实例（懒加载模式）**：节约内存和CPU循环总是好的。由于单例只在第一次被请求时实例化，如果游戏永远不请求，那么它不会被实例化

- **它在运行时实例化**：惰性初始化会使单例尽可能晚的初始化，所以当它初始化时，所有需要的信息都应该可用了。只要没有环状依赖，一个单例在初始化它自己时甚至可以引用另一个单例。

- **可继承单例**

    假设我们需要跨平台的文件系统封装类。为了达到这一点，我们需要它变成文件系统抽象出来的接口，而子类为每个平台实现接口。这是基类：

    ```[c++]
    class FileSystem() {}
    {
    public:
        virtual ~FileSystem() {}
        virtual char* readFile(char* path) = 0;
        virtual void writeFile(char* path, char* contents)
    };
    ```

    然后为一堆平台定义子类：

    ```[c++]
    class PS3FileSystem : public FileSystem
    {
    public:
        virtual char* readFile(char* path)
        {
            // 使用索尼的文件读写API......
        }

        virtual void writeFile(char* path, char* contents)
        {
            // 使用索尼的文件读写API......
        }
    };

    class WiiFileSystem : public FileSystem
    {
    public:
        virtual char* readFile(char* path)
        {
            // 使用任天堂的文件读写API......
        }

        virtual void writeFile(char* path, char* contents)
        {
            // 使用任天堂的文件读写API......
        }
    };
    ```

    下一步，将`FileSystem`变成单例：

    ```[c++]
    class FileSystem
    {
    public:
        static FileSystem& instance();

        virtual ~FileSystem() {}
        virtual char* readFile(char* path) = 0;
        virtual void writeFile(char* path, char* contents)

    protected:
        FileSystem() {}
    };
    ```

    灵巧之处在于如何创建实例：

    ```[c++]
    FileSystem& FileSystem::instance()
    {
    #if PLATFORM == PLAYSTATION3
        static FileSystem *instance = new PS3FileSystem();
    #elif PLATFORM == WII
        static FileSystem *instance = new WiiFileSystem();
    #endif

        return *instance;
    }
    ```

#### 单例模式的危害
- **理解代码更加困难**

- **促进了耦合的发生**

- **对并行不友好**：当我们将某些东西转为全局变量时，我们创建了一块每个线程都能看到并访问的内存，却不知道其他线程是否正在使用那块内存。这种方式带来了死锁，竞争状态，以及其他很难解决的线程同步问题。

### 状态模式
#### 有限状态机的要点
1. 你拥有状态机所有可能状态的集合
2. 状态机同时只能在一个状态
3. 一连串的输入或事件被发送给状态机
4. 每个状态都有一系列的转移，每个转移与输入和另一个状态相关

#### 对状态模式的描述
> 允许一个对象在其内部状态发生变化时改变自己的行为，该对象看起来好像修改了它的类型。

#### 优先状态机在以下情况有用
- 你有个实体，它的行为基于一些内在状态
- 状态可以被严格的分割为相对较少的不相干项目
- 实体响应一系列输入或事件

### 双缓冲模式
#### 意图
> 用序列的操作模拟瞬间或者同时发生的事情

#### 模式
> 定义**缓冲类**封装了**缓冲**：一段可改变的状态。这个缓冲被增量的修改，但我们想要外部的代码将修改视为单一的原子操作。为了实现这点，类保存两个缓冲实例：**下一缓冲**和**当前缓冲**。

> 当信息从缓冲区中读取，它总是读取当前的缓冲区。当信息需要写到缓存，它总是在下一缓冲区上操作。当改变完成后，一个**交换**操作会立刻将当前缓冲区和下一缓冲区交换，这样新缓冲区就是公共可见的了。旧的缓冲区成为下一个重用的缓冲区。

#### 何时使用
- 我们需要维护一些被增量修改的状态
- 在修改到一半的时候，状态可能会被外部请求
- 我们想要防止请求状态的外部代码知道内部的工作方式
- 我们想要读取状态，而且不想等着修改完成

#### 记住
1. 交换本身需要时间

    在状态被修改后，双缓冲需要一个**swap**步骤。这个操作必须是原子的——在交换时，没有代码可以接触到任何一个状态。通常，这就是修改一个指针那么快，但是如果交换消耗的时间长于修改状态的时间，那就毫无益处

2. 我们得保存两个缓冲区

    这个模式的另一个结果就是增加了内存的使用。

### 游戏循环
#### 意图
将游戏的进行和玩家输入解耦，和处理器速度解耦

#### 模式
一个**游戏循环**在游玩中不断运行。 每一次循环，它无阻塞地**处理玩家输入**，**更新游戏状态**，**渲染游戏**。 它追踪时间的消耗并控制游戏的速度。

#### 设计决策
- **使用平台的事件循环**

    - **简单**：不必担心编写和优化自己的游戏核心循环
    - **平台友好**：不必明确地给平台一段时间让它处理它自己的时间，不必缓存事件，不必管理任何平台输入模型和你的不匹配之处
    - **失去了对时间的控制**：平台会在它方便时调用代码。
    
- **使用游戏引擎的循环**

    - **不必自己编写**：编写游戏循环非常需要技巧
    - **不必自己编写**：如果引擎无法满足你真正的需求，你也没法获得控制权
    
- **自己写**

    - **完全的控制**：可以做任何想做的事情，可以为游戏的需求定制开发
    - **需要与平台交互**：应用框架和操作系统通常需要时间片去处理自己的事件和其他工作。如果你拥有应用的核心循环，平台就没有这些时间片了。你得显式定期检查，保证框架没有挂起或者混乱
    
#### 如何控制能量消耗
- **尽可能快的运行**

    这是PC游戏的常态。游戏循环永远不会显示告诉系统休眠。相反，空闲的循环被划在提升FPS或者图像显示效果上了。
    
- **固定帧率**

    移动游戏更加注重游戏的体验质量，而不是最大化图像画质。很多这种游戏都会设置最大帧率（通常是30或60FPS）。如果游戏循环在分配的时间片消耗完之前完成，剩余的时间它会休眠。
    
#### 如何控制游戏速度
- **固定时间步长，没有同步**

    - 简单
    - 游戏速度直接受到硬件和游戏复杂度影响。主要的缺点是，如果有所变化，会直接影响游戏速度。游戏速度与游戏循环紧密相关
    
- **固定时间步长，有同步**

    - 还是很简单
    - 电量友好。这对移动游戏至关重要
    - 游戏不会运行的太快
    - 游戏可能运行的太慢。如果花了太多时间更新和渲染一帧，播放也会减缓。因为这种方案没有分离更新和渲染，它比更高级的方案更容易遇到这点。没法扔掉渲染帧来追上真实时间，游戏本身会变慢
    
- **动态时间步长**

    - 能适应并调整，避免运行得太快或者太慢。如果游戏不能追上真实时间，它用越来越长的时间步长更新，直到追上
    - 让游戏不确定而且不稳定
    
- **固定更新时间步长，动态渲染**

    - 能适应并调整，避免运行得太快或者太慢。只要能实时更新，游戏状态就不会落后于真实时间
    - 更复杂。主要负面问题是需要在实现中写更多东西。 你需要将更新的时间步长调整的尽可能小来适应高端机，同时不至于在低端机上太慢
    
#### 更新方法
#### 意图
通过每次处理一帧的行为模拟一系列独立对象

#### 模式
**游戏世界**管理**对象集合**。每个对象实现一个**更新方法**模拟对象在**一帧**内的行为。每一帧，游戏循环更新集合中的每一个对象。

#### 何时使用
- 你的游戏有很多对象或系统需要同时运行
- 每个对象的行为都与其他的大部分独立
- 对象需要跟着时间进行模拟

#### 设计决策
1. 更新方法在哪个类中？

    - **实体类中**
    
        如果你已经有实体类了，这是最简单的选项， 因为这不会带来额外的类。如果你需要的实体种类不多，这也许可行，但是业界已经逐渐远离这种做法了。
        
        当类的种类很多时，一有新行为就建Entity子类来实现是痛苦的。 当你最终发现你想要用单一继承的方法重用代码时，你就卡住了。
        
    - **组件类**
    
        如果你已经使用了组件模式，你知道这个该怎么做。 这让每个组件独立更新它自己。 更新方法用了同样的方法解耦游戏中的实体，组件让你进一步解耦了单一实体中的各部分。 渲染，物理，AI都可以自顾自了。
        
    - **委托类**
    
        还可将类的部分行为委托给其他的对象。 状态模式可以这样做，你可以通过改变它委托的对象来改变它的行为。 类型对象模式也这样做了，这样你可以在同“种”实体间分享行为。
        
2. 如何处理隐藏对象
游戏中的对象，不管什么原因，可能暂时无需更新。 它们可能是停用了，或者超出了屏幕，或者还没有解锁。 如果状态中的这种对象很多，每帧遍历它们却什么都不做是在浪费CPU循环。

    1. 一种方法是管理单独的“活动”对象集合，那些存储真正需要更新的对象
    
        - **如果你使用单个包括了所有不活跃对象的集合**：**浪费时间**。对于不活跃对象，你要么检查一些“是否启用”的标识，要么调用一些啥都不做的方法。
        
        - **如果你使用单独的集合保存活动对象**：**使用了额外的内存管理第二个集合**。 当你需要所有实体时，通常又需要一个巨大的集合。在那种情况下，这集合是多余的。 在速度比内存要求更高的时候（通常如此），这取舍仍是值得的。
        
    2. 另一个权衡后的选择是使用两个集合，除了活动对象集合的另一个集合只包含不活跃实体而不是全部实体。
    
        - 得保持集合同步。 当对象创建或完全销毁时（不是暂时停用），你得修改全部对象集合和活跃对象集合。
        
### 字节码
#### 意图
将行为编码为虚拟机器上的指令，赋予其数据的灵活性

#### 机器码的好处
- **密集的**。它是一块坚实连续的二进制数据块，没有一位被浪费
- **线性的**。指令被打成包，一条接一条的执行。不会在内存里到处乱跳
- **底层的**。每条指令都做一件小事，有趣的行为从组合中诞生
- **速度快**。在以上所有的要素作用下，机器码运行速度非常快

#### 模式
**指令集**定义了可执行的底层操作。一系列的指令被编码为**字节序列**。**虚拟机**使用**中间值堆栈**依次执行这些指令。通过组合指令，可以定义复杂的高层行为。

#### 何时使用
当需要定义很多行为，而游戏实现语言因为以下原因不能很好地完成任务时使用它：
- 过于底层，繁琐易错
- 编译时间长，迭代缓慢
- 安全性依赖编程者。如果想保证行为不会破坏游戏，你需要将其与代码的其他部分隔开

需要注意的是**字节码比本地代码慢**，所以不适合引擎的性能攸关部分。

#### 设计决策
- **基于栈的虚拟机**

    - **指令短小**。由于每个指令隐式认定在栈顶寻找参数，不需要为任何数据编码。这意味着每条指令可能会非常短，一般只需一个字节。
    
    - **易于生成代码**。当你需要为生成字节码编写编译器或工具时，你会发现更容易生成基于栈的字节码。 由于每个指令隐式在栈顶工作，你只需要以正确的顺序输出指令就可以在它们之间传递参数。
    
    - **会生成更多的指令**。每条指令只能看到栈顶。这意味着，产生像`a = b + c`这样的代码， 你需要单独的指令将`b`和`c`压入栈顶，执行操作，再将结果压入`a`。
    
- **基于寄存器的虚拟机**

    - **指令较长**。 由于指令需要参数记录栈偏移量，单个指令需要更多的位。 例如，一个`Lua`指令——可能是最著名的基于寄存器的虚拟机——占用完整的32位。 它采用6位做指令类型，其余的是参数。
    
    - **指令较少**。由于每个指令可以做更多的工作，你不需要那么多的指令。 有人说，性能会得以提升，因为不需要将值在栈中移来移去了。

#### 可能需要的指令
- **外部基本操作原语**。这是虚拟机与引擎其他部分交互，影响玩家所见的部分。 它们控制了字节码可以表达的真实行为。 如果没有这些，你的虚拟机除了消耗CPU循环以外一无所得。

- **内部基本操作原语**。这些语句在虚拟机内操作数值——文字，算术，比较操作，以及操纵栈的指令。

- **控制流**。当你需要有条件执行或循环执行，你需要控制流。 在字节码这样底层的语言，它们出奇的简单：跳转。

- **抽象**。如果用户开始在数据中定义很多的东西，最终要重用字节码的部分位，而不是复制和粘贴。 你也许需要可调用过程这样的东西。

#### 内部数值表示的不同形式
- **单一数据类型**

    - **简单易用** 你不必担心标记，转换，或类型检查。
    
    - **无法使用不同的数据类型** 这是明显的缺点。将不同类型成塞进单一的表示方式——比如将数字存储为字符串——这是找打。

- **带标记的类型**

    这是动态类型语言中常见的表示法。 所有的值有两部分。 第一部分是类型标识——一个enum——标识存储了数据的类型。
    
    - **数值知道其类型** 这个表示法的好处是可在运行时检查值的类型。 这对动态调用很重要，可以确保没有在类型上面执行其不支持的操作。
    
    - **消耗更多内存** 每个值都要带一些额外的位来标识类型。在像虚拟机这样的底层，这里几位，那里几位，总量就会快速增加。
    
- **无标识的union**

    像前面一样使用union，但是没有类型标识。 你可以将这些位表示为不同的类型，由你确保没有搞错值的类型。
    
    这是静态类型语言在内存中表示事物的方式。 由于类型系统在编译时保证没弄错值的类型，不需要在运行时对其进行验证。
    
    - **结构紧凑** 找不到比只存储需要的值更加有效率的存储方式。
    
    - **速度快** 没有类型标识意味着在运行时无需消耗周期检查它们的类型。这是静态类型语言往往比动态类型语言快的原因之一。
    
    - **不安全** 这是真正的代价。一块错误的字节码，会让你误解一个值，把数字误解为指针，会破坏游戏安全导致崩溃。

- **接口**

    多种类型值的面向对象解决方案是通过多态。接口为不同的类型测试和转换提供虚方法。
    
    - **开放** 可在虚拟机的核心之外定义新的值类型，只要它们实现了基本接口就行。
    
    - **面向对象** 如果你坚持OOP原则，这是做事情“正确”的方式，为特定类型使用多态分配行为，而不是在标签上做switch之类的。

    - **冗长** 必须定义单独的类，包含了每个数据类型的相关行为。

    - **低效** 为了使用多态，必须使用指针，这意味着即使是短小的值，如布尔和数字，也得裹在堆中的对象里。 每使用一个值，你就得做一次虚方法调用。

    在虚拟机核心之类的地方，像这样的性能影响会迅速叠加。 事实上，这引起了许多我们试图在解释器模式中避免的问题。 只是现在的问题不在代码中，而是在值中。

#### 如何生成字节码
- **如果你定义基于文本的语言**

    - **必须定义语法**。 业余和专业的语言设计师小看这件事情的难度。让解析器快乐很简单，让用户快乐很难。语法设计是用户界面设计，当你将用户界面限制到字符构成的字符串，这可没把事情变简单。

    - **必须实现解析器**。 不管名声如何，这部分其实非常简单。无论使用ANTLR或Bison，还是——像我一样——手写递归下降，都可以完成。

    - **必须处理语法错误**。 这是最重要和最困难的部分。 当用户制造了语法和语义错误——他们总会这么干——引导他们返回到正确的道路是你的任务。 解析器只知道接到了意外的符号，给予有用的的反馈并不容易。

    - **可能会对非技术用户关上大门**。 我们程序员喜欢文本文件。结合强大的命令行工具，我们把它们当作计算机的乐高积木——简单，有百万种方式组合。大部分非程序员不这样想。 对他们来说，输入文本文件就像为愤怒机器人审核员填写税表，如果忘记了一个分号就会遭到痛斥。

- **如果你定义了一个图形化创作工具**

    - **必须实现用户界面**。 按钮，点击，拖动，诸如此类。 有些人畏惧它，但我喜欢它。 如果沿着这条路走下去，设计用户界面和工作核心部分同等重要——而不是硬着头皮完成的乱七八糟工作。每点额外工作都会让工具更容易更舒适地使用，并直接导致了游戏中更好的内容。 如果你看看很多游戏制作过程的内部解密，经常会发现制作有趣的创造工具是秘诀之一。
    
    - **有较少的错误情况**。 由于用户通过交互式一步一步地设计行为，应用程序可以尽快引导他们走出错误。而使用基于文本的语言时，直到用户输完整个文件才能看到用户的内容，更难预防和处理错误。
    
    - **更难移植**。 文本编译器的好处是，文本文件是通用的。编译器简单地读入文件并写出。跨平台移植的工作实在微不足道。当你构建用户界面，你必须选择要使用的架构，其中很多是基于某个操作系统。 也有跨平台的用户界面工具包，但他们往往要为对所有平台同样适用付出代价——对所有的平台上同样不适用。
    
### 子类沙箱
#### 意图
用一系列由基类提供的操作定义子类中的行为。

#### 模式
**基类**定义抽象的**沙箱方法**和几个**提供的操作**。将操作标为`protected`，表明它们只为子类所使用。每个推导出的**沙箱子类**用提供的操作实现了沙箱函数。

#### 使用场景
- 你有一个能推导很多子类的基类。
- 基类可以提供子类需要的所有操作。
- 在子类中有行为重复，你想要更容易的在它们间分享代码。
- 你想要最小化子类和程序的其他部分的耦合。

#### 设计决策
1. 首要原则

    - 如果提供的操作只被一个或几个子类使用，将操作加入基类获益不会太多。你向基类添加了会影响所有事物的复杂性，但是只有少数几个类获益。
    
    - 当你调用游戏中其他地方的方法，如果方法没有修改状态就有更少的干扰。它仍然制造耦合，但是这是“安全的”耦合，因为它没有破坏游戏中的任何东西。另一方面，修改状态的调用会和代码库的其他方面紧密绑定，需要三思。打包他们成基类提供的操作是个好的候选项。
    
    - 如果操作只是增加了向外部系统的转发调用，那它就没增加太多价值。那种情况下，也许直接调用外部系统的方法更简单。
    
2. 方法设计原则

    这个模式的挑战是基类中最终加入了很多方法。你可以将一些方法移到其他类中来缓和。基类通过返回对象提供方法。
    
    将提供的操作分流到辅助类可以为你做一些事情：
    
    - 减少基类中的方法。
    
    - 在辅助类中的代码通常更好管理。
    
    - 减少了基类和其他系统的耦合度。
    
