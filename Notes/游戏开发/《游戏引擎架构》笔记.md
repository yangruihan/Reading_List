# 《游戏引擎架构》笔记
## 第一部分 基础
### 第一章 导论
#### 1.1 典型游戏团队的结构
1. 工程师（engineer）
    
    - **运行时**程序员（runtime programmer）
    - **工具**程序员（tool programmer）

2. 艺术家（artist）
    
    - **概念艺术家**（concept artist）
    - **三维建模师**（3D modeler）
    - **纹理艺术家**（texture artist）
    - **灯光师**（lighting artist）
    - **动画师**（animator）
    - **动画捕捉演员**（motion capture actor）
    - **音效设计师**（sound designer）
    - **配音演员**（voice actor）
    - **作曲家**（composer）

3. 游戏设计师（game designer）

4. 制作人（producer）

5. 其他工作人员

6. 发行商（publisher）及工作室

#### 1.2 不同的游戏类型
- 第一人称射击（first person shooting，FPS）

- 平台（platformer）及其他第三人称游戏（third person game）

- 格斗游戏（fighting game）

- 竞速游戏（racing game）

- 实时策略游戏（real-time strategy，RTS）

- 大型多人在线游戏（massively multiplayer online game，MMOG）

- 体育游戏（sports game）

- 角色扮演游戏（role playing game，RPG）

- 上帝模拟游戏（god game）

- 环境或社会模拟游戏（environmental/social simulation）

- 解谜游戏（puzzle game）

- 非电子游戏的移植，如象棋、围棋等

- 基于网页的游戏

- 其他游戏类型

#### 1.3 运行时引擎架构
1. 目标硬件

    代表用来执行游戏的计算机系统或游戏主机

2. 设备驱动程序
    
    设备驱动程序（device driver）是由操作系统或硬件厂商提供的最低阶软件组件。驱动程序负责管理硬件资源，也隔离了操作系统及上层引擎，使上层的软件无须理解不同硬件版本的通信细节差异

3. 操作系统
    
    操作系统（operating system，OS）是一直运行的，协调一台计算机上多个程序的执行

4. 第三方软件开发包和中间件

    大部分游戏引擎都会借用许多第三方软件开发包（software development kit，SDK）及中间件（middleware）

5. 平台独立层

    平台独立层（platform independence layer）在硬件、驱动程序、操作系统及其他第三方软件之上，以此把其余的引擎部分和大部分底层平台隔离。

6. 核心系统
    
    游戏引擎以及其他大规模复杂 C++ 应用软件，都需要一些有用的实用软件（utility），将这类软件称为**核心系统（core system）**

    常见的功能有：

    - 断言（assertion）
    - 内存管理
    - 数学库
    - 自定义数据结构及算法

7. 资源管理

    每个游戏引擎都有某种形式的资源管理器，提供一个或一组统一接口，去访问任何类型的游戏资产及其他引擎输入数据

8. 渲染引擎

    任何游戏引擎中，渲染引擎是最大及最复杂的组件之一

    渲染引擎的设计通常采用**分层架构（layered architecture）**

9. 剖析与调试工具

    剖析游戏性能，以便优化

    调试功能包括调试用绘图、游戏内置菜单、主控台，以及能够录制及回放游戏过程的功能，方便测试与调试

10. 碰撞和物理

    碰撞检测（collision detection）对每个游戏都很重要

    一些游戏包含真实或半真实的动力学模拟（dynamics simulation），在游戏业界称为**物理系统（physics system）**

11. 动画

    含有机或半有机角色（人类、动物、卡通角色，甚至机器人）的游戏，就需要动画系统

    五种基本动画：

    - 精灵/纹理动画（sprite/texture animation）
    - 刚体层次结构动画（rigid body hierarchy animation）
    - 骨骼动画（skeletal animation）
    - 每顶点动画（per-vertex animation）
    - 变形目标动画（morph target animation）

12. 人体学接口设备

    游戏皆要处理玩家输入，而输入来自多个**人体学接口设备（human interface device，HID）**

    常见的 HID：

    - 键盘和鼠标
    - 游戏手柄（joypad)
    - 其他专用游戏控制器，如方向盘、鱼竿、跳舞毯、Wii遥控器（WiiMote）等

    该组件有时称作 **玩家输入/输出（player I/O）** 组件

13. 音频

14. 在线多人/网络

    多人游戏最少有 4 种基本形式：

    - 单屏多人（single-screen multiplayer）
    - 切割屏多人（split-screen multiplayer）
    - 网络多人（networked multiplayer）
    - 大型多人在线游戏（massively multiplayer online game，MMOG）

15. 游戏性基础系统

    **游戏性（gameplay）** 这一术语是指：游戏内进行的活动、支配游戏虚拟世界的规则（rule）、玩家角色的能力（也称为玩家机制/player mechanics）、其他角色和对象的能力、玩家的长短期目标（goal and objective）

    为了连接低阶的引擎子系统和游戏性代码，多数游戏引擎会引入一个软件层，称其为 **游戏性基础层（gameplay foundation layer）**

16. 个别游戏专用子系统

#### 1.4 工具及资产管道
1. 数字内容创作工具
    
    游戏本质上是多媒体应用。游戏引擎的输入数据形式广泛，例如三维网格数据、纹理位图、动画数据、音频文件等。所有源数据皆由美术人员使用 **数字内容创作（digital content creation，DCC）** 应用软件制作

2. 资产调节管道

    DCC 应用软件所使用的数据格式，鲜有适用直接用于游戏的，主要原因有：

    1. DCC 软件在内存中的数据模型，通常比游戏所需的复杂得多

    2. 在游戏中读取 DCC 软件格式的文件，其速度通常过慢，而有些格式更是不公开的专有格式

    当数据自 DCC 软件导出后，有时必须再处理，才能放在游戏引擎里使用。从 DCC 到游戏引擎的管道，有时候称为 **资产调节管道（asset conditioning pipeline）**

3. 三维模型/网格数据

    在游戏中可见的几何图形，通常由两种数据组成：

    1. 笔刷几何图形

        **笔刷几何图形（brush geometry）** 由 **凸包（convex hull）** 集合定义，每个凸包则由多个平面定义

    2. 三维模型（网格）

        对细致的场景元素而言，**三维模型（3D model，也称为 网格/mesh）** 优于笔刷几何图形

4. 骨骼动画数据
    
    **骨骼网格（skeletal mesh）** 是一种特殊的网格，为关节动画而绑定到 **骨骼层次结构（skeletal hierarchy）** 之上

    骨骼网格在看不见的骨骼上形成皮肤，因此，骨骼网格有时候又称为**皮肤（skin）**

5. 音频数据

    **音频片段（audio clip）** 通常由 Sound Forge 或其他音频制作工具导出，有不同的格式和采样率（sampling rate）

6. 粒子系统数据

7. 游戏世界数据及世界编辑器

    游戏引擎的所有内容都集合在游戏世界


### 第二章 专业工具
#### 2.1 版本控制
**版本控制系统（version control system）** 容许多位开发者在同一组文件上工作

版本控制系统容许多位用户同时修改文件，甚至修改同一个文件，并避免互相破坏成果。因为版本控制系统主要供程序员管理源代码，所以有时候又称为 **源代码控制（source control）**

##### 为何使用版本控制
版本控制系统有以下功能：

- 提供中央版本库（repository）
- 保留每个源文件的所有更改记录
- 提供为某些版本加上标签的机制，供以后提取已加标签的版本
- 容许代码从主生产线上建立分支（branch）

#### 2.2 Visual Studio
##### 调试发布生成的窍门
- **学习在调试器中阅读及单步执行反汇编**
- **运用寄存器去推理变量的值或地址**
- **使用地址去检查变量及对象内容**
- **利用静态和全局变量**
- **修改代码**

#### 2.3 剖析工具
**剖析器（profiler）** 能量度代码的执行时间，并能告之每个函数所花的时间

剖析器大致可分为两类：

- **统计式剖析器（statistical profiler）**：此类剖析器是 **不唐突的（unobtrusive）**，意指启动剖析器后，目标代码的执行速度差不多和没使用剖析器时相同

- **测控式剖析器（instrumental profiler）**：此类剖析器能提供最精确、最详尽的计时数据，但是却要以不能实时运行程序为代价——当启动剖析器后，目标程序慢如蜗牛

#### 2.4 内存泄露和损坏检测
使用此类工具可以帮助程序员检测内存泄漏和损坏，避免错误的发生

- **内存泄漏（memory leak）**
    
    如果一块内存在分配后永不释放，就会产生内存泄漏。

- **内存损坏（memory corruption）**

    程序不慎把数据写进内存的错误位置，覆盖了该位置原来的重要数据，也同时未能把数据写到**应该**写的位置。

#### 2.5 其他工具
- **区别工具（difference/diff tool）**：区别工具是用来比较一个文本文档的两个版本，找出版本之间的差异

- **三路合并工具（three-way merge tool）**：当两个人修改同一个文件时，就会产生两组区别。能把两组区别合并成为含两人改动的最终文件的工具，称为三路合并工具

- **十六进制编辑器（hex editor）**：十六进制编辑器用于查看及修改二进制文件的内容

### 第三章 游戏软件工程基础
#### 3.1 重温 C++ 及最佳实践
##### 基本概念
- **类（class）** 是属性（数据）和行为（代码）的集合，共同组成既有用又有意义的整体。类可视为 **规格（specification）**，这些规格描述类的个别 **实例（instance）**——又称为 **对象（object）**。

- **封装（encapsulation）** 是指，对象向外只提供有限接口，隐藏对象的内部状态和实现细节。

- **继承（inheritance）** 能借着**延伸**现有的类去定义新的类。新类可修改或延伸现有类的数据、接口和行为。

- **多重继承（multiple inheritance, MI）** 是指一个类有一个以上的父类。

- **多态（polymorphism）** 是一种语言特征，容许采用单一**共同接口**操作一组不同类型的对象。

- **合成（composition）** 是指，使用**一组互动的**对象去完成高阶任务。

##### 编码标准
1. 编码标准存在的原因：

    1. 一些标准使代码更易读、更易理解、更易维护。

    2. 另一些约定能预防程序员做蠢事，自找麻烦。

2. 编码标准内容：

    - **接口为王**：保持接口（`.h`文件）整洁、简单、极小、易于理解，并有良好注释。

    - **好名字促进理解及避免混淆**：持续使用能直接反映类、函数、变量用途的直观名字。
    
    - **不要给命名空间添乱**：使用 C++ 命名空间或统一的名字前缀，以确保自己的符号（symbol）不会和其他库的符号冲突。

    - **遵从最好的 C++ 实践**

    - **始终如一**：始终遵守编码标准内容。

    - **显露错误**：所谓最“整洁”的代码，并不需要是表面看起来简洁整齐的代码，而更重要的是，代码的编写方法能**容易显露**常见的编程错误。

#### 3.2 C/C++ 的数据、代码及内存
- 大于8位（1字节）的值称为 **多字节量（multi-byte quantity）**。

- 内存中存储多字节整数有两种方式：

    - **小端（little-endian）**：若微处理器存储多字节值的最低有效字节于较低的内存位置，则该微处理器就是**小端**处理器。

    - **大端（big-endian）**：若微处理器存储多字节值的最高有效字节于较低的内存位置，则该微处理器就是**大端**处理器。

- 处理字节序问题的方法：

    1. 所有数据以文字方式写入文件。多字节数值以一串十进制数字，每数字一个字节写入。但此方法会浪费磁盘空间。

    2. 工具先转换数据字节序，然后再把转换后的数据写进二进制文件。
    
- 声明与定义：

    - **声明（declaration）** 是数据对象或函数的描述。声明使编译器知道实体（数据对象或函数）的名字，以及其数据类型或函数签名（function signature，即函数的返回值类型、一个至多个参数类型）。

    - **定义（definition）** 则是程序中个别内存区域的描述。此内存区域可能用来放置变量、struct或class的实例，以及函数的机器码。

- **可执行映像**一般最少由以下4个段组成：

    1. **代码段（text/code segment）** ：此段包含程序中定义的全部函数的可执行机器码。
    
    2. **数据段（data segment）** ：此段包含全部**获初始化**的全局及静态变量。链接器为这些变量分配所需内存，其内存布局将会和程序执行时完全一样，并且链接器会填入适当的初始值。
    
    3. **BSS段（BSS segment）** ：“BSS”是过时的名字，原意是“由符号开始的块（block started by symbol）”。BSS段包含程序中定义的所有**未初始化**全局变量和静态变量。

    4. **只读数据段（read only data segment）** ：此段又称为**rodata**段，包含程序中定义的只读（常量）全局变量。

- 程序堆栈：

    当可执行程序被载入内存时，操作系统会保留一块称为 **程序堆栈（program stack）** 的内存。当调用函数时，一块连续的内存就会压入栈，此内存块称为 **堆栈帧（stack frame）**。若函数`a()`调用函数`b()`，函数`b()`的新堆栈帧就会压入`a()`堆栈帧之上。当`b()`返回时，其堆栈帧就会弹出，并于调用`b()`之后的位置继续执行`a()`。
    
    堆栈帧存储3类数据：
    
    1. 堆栈帧存储调用函数的 **返回地址（return address）**。当函数返回时，就可以凭这一数据继续执行调用方的函数。
        
    2. 堆栈帧保存相关**CPU寄存器**的内容。当函数返回时，各寄存器就会还原至调用方可继续执行的状态。
        
    3. 堆栈帧也包含函数里的所有 **局部变量（local variable）**，或称为 **自动变量（automatic variable）**。

- `static`关键字的不同含义

    - 当用于文件作用域时，`static`意味着“限制变量或函数的可见性，只有本`.cpp`文件才能使用该变量或函数”。
    
    - 当用于函数作用域时，`static`意味着“变量为全局，非自动，只在本函数内可见”。
    
    - 当用于`struct`或`class`声明时，`static`意味着“该变量非一般成员变量，而是类似于全局变量”。
    

