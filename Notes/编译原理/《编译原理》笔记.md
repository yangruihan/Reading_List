# 编译原理

## 第1章 引论

程序设计语言是向人以及计算机描述计算过程的记号



### 1.1 语言处理器

- 一个 **[编译器（compiler）](https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8)** 就是一个程序，它可以阅读以某一种语言（源语言）编写的程序，并把该程序翻译成一个等价的、用另一个语言（目标语言）编写的程序

- 编译器的重要任务之一是 **报告它在翻译过程中发现的源程序中的错误**

- **[解释器（interpreter）](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8)** 是另一种常见的语言处理器。它并不通过翻译的方式生成目标程序，直接利用用户提供的输入执行源程序中指定的操作



### 1.2 一个编译器的结构

1. 编译器由两个部分组成：**分析部分** 和 **综合部分**

- **分析（analysis）部分** 把源程序分解成为多个组成要素，并在这些要素之上加上语法结构，然后使用这个结构来创建该源程序的一个 **中间表示**

- **综合（synthesis）部分**根据 **中间表示** 和 **符号表** 中的信息来构造用户期待的 **目标程序**

- **分析部分** 经常被称为编译器的 **前端（front end）**，**综合部分** 称为 **后端（back end）**



2. 编译器执行了一组 **步骤（phase）**，每个步骤把源程序的一种表示方式转换成另一种表示方式：

- **步骤**：

   1. **词法分析**

      第一个步骤称为 **词法分析（lexical analysis）** 或 **扫描（scanning）**。词法分析器读入组成源程序的**字符流**，并且将它们组织成有意义的 **词素（lexeme）** 序列。对于每个词素，词法分析器产生如下形式的 **词法单元（token）** 作为输出：`<token-name, attribute-value>`

      - 在这个词法单元中，第一个分量`token-name`是一个由语法分析步骤使用的抽象符号，第二个分量`attribute-value`指向符号表中关于这个词法单元的条目

   2. **语法分析**

      第二个步骤称为 **语法分析（syntax analysis）** 或 **解析（parsing）**。语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建 **树形** 的 **中间表示**

      - 常用的表示方法是**语法树（syntax tree）**，树中的每个内部结点表示一个运算，而该结点的子结点表示该运算的分量

   3. **语义分析**

      **语义分析器（semantic analyzer）** 使用**语法树**和**符号表**中的信息来检查源程序是否和语言定义的语义一致

      - 语义分析的一个重要部分是 **类型检查（type checking）**，编译器检查每个运算符是否具有匹配的运算分量

   4. **中间代码生成**

      在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示

   5. **代码优化**

      机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码

   6. **代码生成**

      代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言


- 符号表管理

  编译器的重要功能之一是记录源程序中使用的变量的名字，并收集和每个名字的各种属性有关的信息

- 将多个步骤组合成趟

  在一个特定的实现中，多个步骤的活动可以被组合成一 **趟（pass）**。每趟读入一个输入文件并产生一个输出文件



### 1.3 程序设计语言的发展历程

- 第一代语言是 **机器语言**，第二代语言是 **汇编语言**，而第三代语言是 **Fortran**、**Cobol**、**Lisp**、**C**、**C++**、**C#**及**Java** 这样的 **高级程序设计语言**。第四代语言 **是为特定应用设计的语言**

- 另一种语言分类方式把程序中指明 **如何完成一个计算任务的语言** 称为 **强制式（imperative）** 语言，而把程序中指明 **要进行哪些计算的语言** 称为 **声明式（declarative）** 语言

- 术语 **冯•洛伊曼语言（von Neumann language）** 是指以冯•洛伊曼计算机体系结构为计算模型的程序设计语言

- **[面向对象语言（object-oriented language）](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)** 指的是支持 **面向对象编程** 的语言，**面向对象编程是指** 用一组相互作用的对象组成程序的编程风格

- **[脚本语言（scripting language）](https://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80)** 是具有高层次运算符的 **解释型** 语言，它通常被用于把多个计算过程“ **粘合** ”在一起



### 1.4 构建一个编译器的相关科学

编译器的设计中有很多通过数学方法抽象出问题本质从而解决现实世界中复杂问题的完美例子

1. 编译器设计和实现中的建模

   对编译器的研究主要是有关如何设计正确的数学模型和选择正确算法的研究。设计和选择时，还需要考虑到对通用性及功能的要求与简单性及有效性之间的平衡

   最基本的数学模型是 **[有穷状态自动机](https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA)**、**[正则表达式](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)**、**[上下文无关文法](https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95)**、**[树形结构](https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B)**


2. 代码优化的科学

- 在编译器设计中，术语“优化”是指编译器为了生成比较浅显直观的代码更加高效的代码而做的工作

- **编译器优化必须满足下面的设计目标：**
  - 优化必须是正确的，也就是说，不能改变被编译程序的含义
  - 优化必须能够改善很多程序的性能
  - 优化所需的时间必须保持在合理的范围内
  - 所需要的工程方面的工作必须是可管理的



### 1.5 编译技术的应用

编译器设计并不只是关于编译器的

1. 高级程序设计语言的实现

2. 针对计算机体系结构的优化

   几乎所有高性能系统都利用了两种技术：**并行（parallelism）** 和 **内存层次结构（memory hierarchy）**

3. 新计算机体系结构的设计
4. 程序翻译
5. 软件生产率工具



### 1.6 程序设计语言基础

1. **静态和动态的区别**

- 如果一个语言使用的策略支持编译器静态决定某个问题，那么我们说这个语言使用了一个 **静态（static）策略**，或者说这个问题可以在 **编译时刻（compile time）** 决定。另一方面，一个只允许在运行程序的时候做出决定的策略被称为 **动态策略（dynamic policy）**，或者被认为需要在 **运行时刻（run time）** 做出决定
- x 的一个声明的 **作用域（scope）** 是指程序的一个区域，在其中对 x 的使用都指向这个声明。如果仅通过阅读程序就可以确定一个声明的作用域，那么这个语言使用的是 **静态作用域（static scope）**，或者说 **词法作用域（lexical scope）**。否则，这个语言使用的是 **动态作用域（dynamic scope）**。



2. **环境与状态**

- **环境（environment）** 是一个从名字到存储位置的映射
- **状态（state）** 是一个从内存位置到它们的值的映射



3. **静态作用域和块结构**

   包括 C 语言和它的同类语言在内的大多数语言使用静态作用域，C 语言的作用域规则是基于程序结构的，一个声明的作用域由该声明在程序中出现的位置隐含地决定



	> 名字、标识符和变量
	>
	> 虽然术语“名字”和“变量”通常指的是同一个事物，我们还是要很小心地使用它们，以便区别编译时刻的名字和名字在运行时刻所指的内存位置。
	>
	> **标识符（identifier）** 是一个字符串，通常由字母和数字组成。它用来指向（标记）一个实体，比如一个数据对象、过程、类、或者类型。所有的标识符都是名字，但并不是所有的名字都是标识符。名字也可以是一个表达式。比如名字 *x.y* 可以表示 *x* 所指的一个结构中的字段 *y*。这里，*x* 和 *y* 是标识符，而 *x.y* 是一个名字。像 *x.y* 这样的复合名字称为 **受限名字（qualified name）**。
	>
	> **变量** 指向存储中的某个特定的位置。同一个标识符被多次声明是很常见的事情，每一个这样的声明引入一个新的变量。即使每个标识符只被声明一次，一个递归过程中的局部标识符将在不同的时刻指向不同的存储位置。



4. **显示访问控制**

   类和结构为它们的成员引入了新的作用域



	> 声明和定义
	>
	> 程序设计语言概念中的两个看起来相似的属于“声明”和“定义”实际上有着很大的不同。声明告诉我们事物的类型，而定义告诉我们它们的值。因此，`int i`是一个 *i* 的声明，而`i = 1`是 *i* 的一个定义（定值）。
	>
	> 当我们处理方法或者其他过程时，这个区别就更加明显。在 C++ 中，通过给出了方法的参数及结果的类型（通常称为该方法的范型），在类的定义中声明这个方法。然后，这个方法在另一个地方被定义，即在另一个地方给出了执行这个方法的代码。类似地，我们会经常看到在一个文件中定义了一个 C 语言的函数，然后在其它使用这个函数的文件中声明这个函数。



5. **动态作用域**

   从技术上讲，如果一个作用域策略依赖于一个或多个只有在程序执行时刻才能知道的因素，它就是动态的



6. **参数传递机制**

- **值调用**

  在 **值调用（call-by-value）** 中，会对实在参数求值（如果它是表达式）或拷贝（如果它是变量）

- **引用调用**

  在 **引用调用（call-by-reference）** 中，实在参数的地址作为相应的参数的值被传递给调用者

- **名调用**

  它要求被调用者的运行方式好像是用实在参数以字面方式替换了被调用者的代码中的形式参数一样



7. **别名**

   引用调用或者其他类似的方法，比如像 Java 中那样把对象的引用当作值传递，会引起一个有趣的结果。有可能两个形式参数指向同一个位置，这样的变量称为另一个变量的 **别名（alias）**。


### 1.7 第1章总结

- **语言处理器**：一个集成的软件开发环境，其中包括很多种类的语言处理器，比如编译器、解释器、汇编器、连接器、加载器、调试器以及程序概要提取工具
- **编译器的步骤**：一个编译器的运作需要一系列的步骤，每个步骤把源程序从一个中间表示转换成另一个中间表示
- **机器语言和汇编语言**：机器语言是第一代程序设计语言，然后是汇编语言。使用这些语言进行编程既费时，有容易出错
- **编译器设计中的建模**：编译器设计是理论对实践有很大影响的领域之一。已知在编译器设计中有用的模型包括自动机、文法、正则表达式、树形结构和很多其他理论概念
- **代码优化**：虽然代码不能真正达到最优化，但提高代码效率的科学既复杂又非常重要。它是编译技术研究的一个主要部分
- **高级语言**：随着时间的流逝，程序设计语言担负了越来越多的原先由程序员负责的任务，比如内存管理、类型一致性检查或代码的并发执行
- **编译器和计算机体系结构**：编译器技术影响了计算机的体系结构，同时也受到体系结构发展的影响。体系结构中的很多现代创新都依赖于编译器能够从源程序中抽取出有效利用硬件能力的机会
- **软件生产率和软件安全性**：使得编译器能够优化代码的技术同样能够用于多种不同的程序分析任务。这些任务既包括探测常见的程序错误，也包括发现程序可能会受到已被黑客们发现的多种入侵方式之一的侵害
- **作用域规则**：一个 *x* 的声明的作用域是一段上下文，在此上下文中对 *x* 的使用指向这个声明。如果仅仅通过阅读某个语言的程序就可以确定其作用域，那么这个语言就使用了 **静态作用域**，或者说 **词法作用域**。否则这个语言就是用了 **动态作用域**
- **环境**：名字和内存位置关联，然后再和值相关联。这个情况可以使用 **环境** 和 **状态** 来描述。其中环境把名字映射成为存储位置，而状态则把位置映射到它的值
- **块结构**：允许语句块互相嵌套的语言成为 **块结构** 的语言。假设一个块中有一个 *x* 的声明 *D*，而嵌套于这个块中的块 *B* 中有一个对名字 *x* 的使用。如果在这两个块之间没有其他声明了 *x* 的块，那么这个 *x* 的使用位于 *D* 的作用域内
- **参数传递**：参数可以通过值或引用的方式从调用过程传递给被调用过程。当通过值传递方式传递大型对象时，实际被传递的值是指向这些对象本身的引用。这样就变成了一个高效的引用调用
- **别名**：当参数被以引用传递方式（高效地）传递时，两个形式参数可能会指向同一个对象。这会造成一个变量的修改改变了另一个变量的值





