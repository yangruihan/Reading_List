# 编译原理

## 第1章 引论

程序设计语言是向人以及计算机描述计算过程的记号

### 1.1 语言处理器

- 一个 **[编译器（compiler）](https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8)** 就是一个程序，它可以阅读以某一种语言（源语言）编写的程序，并把该程序翻译成一个等价的、用另一个语言（目标语言）编写的程序

- 编译器的重要任务之一是**报告它在翻译过程中发现的源程序中的错误**

- **[解释器（interpreter）](https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%AD%AF%E5%99%A8)** 是另一种常见的语言处理器。它并不通过翻译的方式生成目标程序，直接利用用户提供的输入执行源程序中指定的操作

### 1.2 一个编译器的结构

1. 编译器由两个部分组成：**分析部分**和**综合部分**

- **分析（analysis）部分**把源程序分解成为多个组成要素，并在这些要素之上加上语法结构，然后使用这个结构来创建该源程序的一个**中间表示**

- **综合（synthesis）部分**根据**中间表示**和**符号表**中的信息来构造用户期待的**目标程序**

- **分析部分**经常被称为编译器的**前端（front end）**，**综合部分**称为**后端（back end）**



2. 编译器执行了一组**步骤（phase）**，每个步骤把源程序的一种表示方式转换成另一种表示方式：

- **步骤**：

   1. **词法分析**

      第一个步骤称为 **词法分析（lexical analysis）** 或 **扫描（scanning）**。词法分析器读入组成源程序的**字符流**，并且将它们组织成有意义的 **词素（lexeme）** 序列。对于每个词素，词法分析器产生如下形式的 **词法单元（token）** 作为输出：`<token-name, attribute-value>`

      - 在这个词法单元中，第一个分量`token-name`是一个由语法分析步骤使用的抽象符号，第二个分量`attribute-value`指向符号表中关于这个词法单元的条目

   2. **语法分析**

      第二个步骤称为 **语法分析（syntax analysis）** 或 **解析（parsing）**。语法分析器使用由词法分析器生成的各个词法单元的第一个分量来创建**树形**的**中间表示**

      - 常用的表示方法是**语法树（syntax tree）**，树中的每个内部结点表示一个运算，而该结点的子结点表示该运算的分量

   3. **语义分析**

      **语义分析器（semantic analyzer）** 使用**语法树**和**符号表**中的信息来检查源程序是否和语言定义的语义一致

      - 语义分析的一个重要部分是 **类型检查（type checking）**，编译器检查每个运算符是否具有匹配的运算分量

   4. **中间代码生成**

      在把一个源程序翻译成目标代码的过程中，一个编译器可能构造出一个或多个中间表示

   5. **代码优化**

      机器无关的代码优化步骤试图改进中间代码，以便生成更好的目标代码

   6. **代码生成**

      代码生成器以源程序的中间表示形式作为输入，并把它映射到目标语言


- 符号表管理

  编译器的重要功能之一是记录源程序中使用的变量的名字，并收集和每个名字的各种属性有关的信息

- 将多个步骤组合成趟

  在一个特定的实现中，多个步骤的活动可以被组合成一 **趟（pass）**。每趟读入一个输入文件并产生一个输出文件

### 1.3 程序设计语言的发展历程

- 第一代语言是**机器语言**，第二代语言是**汇编语言**，而第三代语言是**Fortran**、**Cobol**、**Lisp**、**C**、**C++**、**C#**及**Java**这样的**高级程序设计语言**。第四代语言**是为特定应用设计的语言**

- 另一种语言分类方式把程序中指明**如何完成一个计算任务的语言**称为 **强制式（imperative）** 语言，而把程序中指明**要进行哪些计算的语言**称为 **声明式（declarative）** 语言

- 术语 **冯•洛伊曼语言（von Neumann language）** 是指以冯•洛伊曼计算机体系结构为计算模型的程序设计语言

- **[面向对象语言（object-oriented language）](https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1)**指的是支持**面向对象编程**的语言，**面向对象编程是指**用一组相互作用的对象组成程序的编程风格

- **[脚本语言（scripting language）](https://zh.wikipedia.org/wiki/%E8%84%9A%E6%9C%AC%E8%AF%AD%E8%A8%80)**是具有高层次运算符的**解释型**语言，它通常被用于把多个计算过程“**粘合**”在一起

### 1.4 构建一个编译器的相关科学

编译器的设计中有很多通过数学方法抽象出问题本质从而解决现实世界中复杂问题的完美例子

1. 编译器设计和实现中的建模

   对编译器的研究主要是有关如何设计正确的数学模型和选择正确算法的研究。设计和选择时，还需要考虑到对通用性及功能的要求与简单性及有效性之间的平衡

   最基本的数学模型是 **[有穷状态自动机](https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA)**、**[正则表达式](https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F)**、**[上下文无关文法](https://zh.wikipedia.org/wiki/%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E6%96%87%E6%B3%95)**、**[树形结构](https://zh.wikipedia.org/wiki/%E6%A8%B9%E7%8B%80%E7%B5%90%E6%A7%8B)**

2. 代码优化的科学

- 在编译器设计中，术语“优化”是指编译器为了生成比较浅显直观的代码更加高效的代码而做的工作

- **编译器优化必须满足下面的设计目标：**
  - 优化必须是正确的，也就是说，不能改变被编译程序的含义
  - 优化必须能够改善很多程序的性能
  - 优化所需的时间必须保持在合理的范围内
  - 所需要的工程方面的工作必须是可管理的

### 1.5 编译技术的应用

编译器设计并不只是关于编译器的

1. 高级程序设计语言的实现

2. 针对计算机体系结构的优化

   几乎所有高性能系统都利用了两种技术：**并行（parallelism）** 和 **内存层次结构（memory hierarchy）**

3. 新计算机体系结构的设计
4. 程序翻译
5. 软件生产率工具